import { useState, useEffect, useRef } from 'react';
import { createRoot } from 'react-dom/client';

// ============================================
// G検定クイズデータ（9章×20問=180問）
// ============================================

const quizData = {
  chapter1: {
    id: 1, title: "人工知能をめぐる動向", subtitle: "AI・ML・DLの歴史と基本概念",
    character: "🌌", characterName: "AI史の語り部", quote: "歴史を知る者が未来を創る", color: "#6366f1",
    questions: [
      { id: 1, question: "ある企業がAIを活用した顧客対応システムを導入した。このシステムは顧客からの問い合わせに対して適切な回答を返すことができるが、社内では「これは本当の知能ではなく、単なるパターンマッチングだ」という声が上がった。このような、AIが何かを達成しても「それは本当の知能ではない」と人間が考える傾向を示す心理現象はどれか。", options: ["フレーム問題", "AI効果", "シンボルグラウンディング問題", "中国語の部屋"], correct: 1, explanation: "AI効果とは、AIが何らかのタスクを達成すると、人間がそれを「本当の知能ではない」「単なる計算に過ぎない」と矮小化して捉える傾向のことです。", keywords: ["AI効果"] },
      { id: 2, question: "1956年にアメリカで開催され、「Artificial Intelligence」という用語が初めて使用された歴史的な会議について、その主催者と会議名の正しい組み合わせはどれか。", options: ["アラン・チューリングが主催したチューリング会議", "ジョン・マッカーシーらが主催したダートマス会議", "マービン・ミンスキーが単独で主催したMIT会議", "ハーバート・サイモンが主催したカーネギーメロン会議"], correct: 1, explanation: "1956年のダートマス会議は、ジョン・マッカーシー、マービン・ミンスキー、クロード・シャノンらが主催し、AI研究の正式な出発点となりました。", keywords: ["ダートマス会議"] },
      { id: 3, question: "初期のAI研究では「積み木の世界」のような限定された環境でAIを動作させることに成功したが、現実世界の複雑さには対応できなかった。SHRDLUのような限定環境でのみ機能するシステムが示した問題を何と呼ぶか。", options: ["フレーム問題", "トイ・プロブレム", "知識獲得のボトルネック", "シンボルグラウンディング問題"], correct: 1, explanation: "トイ・プロブレム（おもちゃの問題）は、AIが理想的な限定環境では動作するが、現実世界の複雑さには対応できないという問題です。", keywords: ["トイ・プロブレム", "SHRDLU"] },
      { id: 4, question: "哲学者ジョン・サールが提唱した思考実験「中国語の部屋」が批判している立場として最も適切なものはどれか。", options: ["チューリングテストの妥当性", "記号操作だけで意味理解が成立するという強いAIの立場", "機械学習の有効性", "ニューラルネットワークの表現力"], correct: 1, explanation: "中国語の部屋は、記号を操作するだけでは意味の理解にならないことを示し、「強いAI」（機械が真に心を持つ）という立場を批判しています。", keywords: ["中国語の部屋", "強いAIと弱いAI"] },
      { id: 5, question: "1980年代に全盛を迎えたエキスパートシステムが衰退した主な理由として最も適切なものはどれか。", options: ["計算速度が遅く実用的でなかった", "専門家の暗黙知をルール化することが困難で知識獲得のボトルネックが生じた", "インターネットの普及により不要になった", "ディープラーニングにすべてのタスクで性能が上回られた"], correct: 1, explanation: "知識獲得のボトルネックは、専門家が持つ暗黙知や経験則をif-thenルールとして明文化することの困難さを指し、エキスパートシステムの限界となりました。", keywords: ["知識獲得のボトルネック", "エキスパートシステム"] },
      { id: 6, question: "「現在の状況から次の状況へ移行する際に、変化しないものは何かを明示的に記述することが困難である」という問題を何と呼ぶか。", options: ["組合せ爆発", "フレーム問題", "シンボルグラウンディング問題", "トイ・プロブレム"], correct: 1, explanation: "フレーム問題は、AIが状況変化において「何が変わり何が変わらないか」を判断することの難しさを指します。1969年にマッカーシーとヘイズによって提起されました。", keywords: ["フレーム問題"] },
      { id: 7, question: "2012年のILSVRC（画像認識コンペティション）で従来手法を大幅に上回る精度を達成し、ディープラーニングブームのきっかけとなったモデルはどれか。", options: ["LeNet", "AlexNet", "VGGNet", "ResNet"], correct: 1, explanation: "AlexNetは、GPUによる並列計算、ReLU活性化関数、ドロップアウトなど重要な技術を導入し、ILSVRC2012で圧勝してディープラーニング革命の契機となりました。", keywords: ["AlexNet", "ILSVRC", "ImageNet"] },
      { id: 8, question: "ゲーム木探索において、Mini-Max法の探索効率を向上させ、評価が不要な枝を刈り取る手法はどれか。", options: ["幅優先探索", "深さ優先探索", "αβ法", "モンテカルロ法"], correct: 2, explanation: "αβ法（アルファベータ枝刈り）は、Mini-Max法の探索において、ゲームの結果に影響を与えない枝を探索せずに刈り取り、効率を大幅に向上させます。", keywords: ["αβ法", "Mini-Max法", "探索木"] },
      { id: 9, question: "意味ネットワークにおいて、「犬は動物である」という関係を表現するために使用される関係タイプはどれか。", options: ["has-a関係", "is-a関係", "part-of関係", "instance-of関係"], correct: 1, explanation: "is-a関係は上位概念との包含関係を表します。「犬は動物の一種である」という階層構造を表現します。has-aは属性、part-ofは部分-全体関係です。", keywords: ["意味ネットワーク", "is-aの関係・has-aの関係・part-ofの関係"] },
      { id: 10, question: "2011年にクイズ番組「Jeopardy!」で人間のチャンピオンに勝利した、自然言語処理と大規模知識ベースを組み合わせた質問応答システムはどれか。", options: ["Deep Blue", "Watson", "AlphaGo", "GPT"], correct: 1, explanation: "IBM Watsonは、自然言語で出題されるクイズに回答する質問応答（Question Answering）システムで、複数の仮説を生成・評価して回答を導きます。", keywords: ["ワトソン", "QuestionAnswering"] },
      { id: 11, question: "チューリングテストの説明として最も適切なものはどれか。", options: ["機械が数学的問題を人間より速く解けるかをテストする", "人間の審査員がテキストベースの会話で相手が機械か人間かを判定する", "機械が自己意識を持っているかを測定する", "機械が倫理的判断ができるかを評価する"], correct: 1, explanation: "チューリングテストは、1950年にアラン・チューリングが提案した、機械が知能を持つかどうかを判定する操作的定義です。", keywords: ["チューリングテスト", "ローブナーコンテスト"] },
      { id: 12, question: "「記号（シンボル）と現実世界の意味を結びつけることの困難さ」を示す問題を何と呼ぶか。解決には身体性が重要とされている。", options: ["フレーム問題", "シンボルグラウンディング問題", "知識獲得のボトルネック", "中国語の部屋"], correct: 1, explanation: "シンボルグラウンディング問題は、コンピュータ内の記号「リンゴ」と実際のリンゴを結びつけることの困難さを示し、身体性による解決が提案されています。", keywords: ["シンボルグラウンディング問題", "身体性"] },
      { id: 13, question: "2016年にプロ棋士イ・セドル九段を破ったDeepMindの囲碁AIが使用した主要技術の組み合わせとして正しいものはどれか。", options: ["ルールベース推論とエキスパートシステム", "深層強化学習とモンテカルロ木探索", "サポートベクターマシンと決定木", "線形回帰とロジスティック回帰"], correct: 1, explanation: "AlphaGoは、CNNによる局面評価、方策ネットワーク、モンテカルロ木探索、そして強化学習による自己対戦学習を組み合わせています。", keywords: ["アルファ碁 (AlphaGo)", "モンテカルロ法"] },
      { id: 14, question: "1980年に福島邦彦が提案し、後のCNN（畳み込みニューラルネットワーク）の原型となったモデルはどれか。", options: ["パーセプトロン", "ネオコグニトロン", "ボルツマンマシン", "ホップフィールドネットワーク"], correct: 1, explanation: "ネオコグニトロンは、視覚野のS細胞（特徴抽出）とC細胞（位置不変性）の機能を模倣し、CNNの畳み込み層とプーリング層の設計に影響を与えました。", keywords: ["ネオコグニトロン"] },
      { id: 15, question: "大量のデータから統計的手法やAI技術を用いて有用なパターンや知識を発見する技術は何と呼ばれるか。", options: ["セマンティックWeb", "データマイニング", "オントロジー", "エキスパートシステム"], correct: 1, explanation: "データマイニングは、大量のデータから有用なパターンを発見する技術で、顧客分析や不正検出などに活用されています。", keywords: ["データマイニング"] },
      { id: 16, question: "ヤン・ルカンらが1998年に発表し、手書き数字認識で成功を収めた初期のCNNモデルはどれか。", options: ["AlexNet", "LeNet", "ResNet", "VGGNet"], correct: 1, explanation: "LeNetは畳み込み層とプーリング層を組み合わせた初期のCNNで、郵便番号の自動読み取りなどに実用化されました。", keywords: ["LeNet"] },
      { id: 17, question: "AIが人間の知能を超え、自己改良により急速に知能が向上する仮説的な時点を何と呼ぶか。", options: ["AI効果", "シンギュラリティ", "フレーム問題", "知識爆発"], correct: 1, explanation: "シンギュラリティ（技術的特異点）は、レイ・カーツワイルらが提唱する概念で、2045年頃の到来が予測されていますが議論が続いています。", keywords: ["シンギュラリティ"] },
      { id: 18, question: "テキスト、画像、音声などの新しいコンテンツを生成できるAIの総称として適切なものはどれか。", options: ["エキスパートシステム", "生成AI", "推薦システム", "検索エンジン"], correct: 1, explanation: "生成AIは、GPT（テキスト）、DALL-E（画像）、Diffusion Model（画像）など多様なモデルを含み、2022年以降のChatGPT等により広く認知されました。", keywords: ["生成AI"] },
      { id: 19, question: "概念や関係を形式的に定義し、知識を機械が理解可能な形で表現する枠組みは何と呼ばれるか。", options: ["データマイニング", "オントロジー", "クラスタリング", "回帰分析"], correct: 1, explanation: "オントロジーは特定のドメインにおける概念とその関係を形式的に定義した知識表現の枠組みで、セマンティックWebの基盤技術です。", keywords: ["オントロジー", "セマンティックWeb"] },
      { id: 20, question: "機械学習の最大の特徴として最も適切なものはどれか。", options: ["人間がルールを明示的にプログラムする必要がある", "データからパターンを自動的に学習し明示的なルール記述が不要", "計算速度がルールベースより常に速い", "小規模データでのみ有効である"], correct: 1, explanation: "機械学習の特徴は、人間がルールを明示的にプログラムしなくても、データからパターンやルールを自動的に学習できる点です。", keywords: ["機械学習"] }
    ]
  },
  chapter2: {
    id: 2, title: "機械学習の概要", subtitle: "教師あり・なし学習と強化学習",
    character: "📚", characterName: "学習の三賢者", quote: "データこそが最高の教師", color: "#10b981",
    questions: [
      { id: 1, question: "製造業の企業が、過去の製品検査データ（製品画像と良品/不良品のラベル）を用いて自動検査システムを構築する場合、最も適した機械学習の種類と問題設定はどれか。", options: ["教師なし学習によるクラスタリング", "教師あり学習による分類問題", "強化学習による最適化問題", "教師あり学習による回帰問題"], correct: 1, explanation: "正解ラベル（良品/不良品）が存在し、カテゴリを予測する問題であるため、教師あり学習の分類問題として定式化します。", keywords: ["教師あり学習", "分類問題"] },
      { id: 2, question: "決定木をベースとしたアンサンブル学習手法であるランダムフォレストの特徴として正しいものはどれか。", options: ["複数の決定木を逐次的に学習し前の木の誤差を補正する", "ブートストラップサンプリングと特徴量のランダム選択を組み合わせたバギングの一種", "並列学習が不可能でバギングより低速", "単一の決定木より解釈性が高い"], correct: 1, explanation: "ランダムフォレストは、各決定木の学習時にブートストラップサンプリングでデータを選び、特徴量もランダムに選択することで多様な木を生成します。", keywords: ["ランダムフォレスト", "バギング", "決定木"] },
      { id: 3, question: "サポートベクターマシン（SVM）の特徴として最も適切なものはどれか。", options: ["常に線形分離可能なデータにのみ適用可能", "マージン最大化を目的としカーネルトリックにより非線形分離も可能", "大規模データにディープラーニングより効率的", "教師なし学習の代表的手法"], correct: 1, explanation: "SVMはクラス間のマージンを最大化し、カーネルトリックで高次元空間に写像することで非線形分離を実現できます。", keywords: ["サポートベクターマシン (SVM)", "マージン最大化", "カーネルトリック"] },
      { id: 4, question: "ECサイトの「この商品を買った人はこの商品も買っています」という推薦に使われる手法と、その課題の組み合わせとして正しいものはどれか。", options: ["コンテンツベースフィルタリング：嗜好の変化に対応困難", "協調フィルタリング：新規ユーザーや商品に推薦困難なコールドスタート問題", "k-means法：クラスタ数の事前設定が必要", "主成分分析：情報損失が大きい"], correct: 1, explanation: "協調フィルタリングはユーザー間の行動類似性に基づく推薦手法で、履歴がない新規ユーザー・商品への推薦が困難なコールドスタート問題があります。", keywords: ["協調フィルタリング", "コールドスタート問題"] },
      { id: 5, question: "k-means法に関する説明として正しいものはどれか。", options: ["クラスタ中心までの距離の二乗和を最大化する", "事前にクラスタ数kを指定し初期値により結果が変わる可能性がある", "階層的クラスタリングでデンドログラムを出力する", "ラベル付きデータを必要とする教師あり学習"], correct: 1, explanation: "k-means法は教師なし学習のクラスタリング手法で、クラスタ数kの事前指定が必要で、初期値依存性があります。", keywords: ["k-means法", "クラスタリング"] },
      { id: 6, question: "強化学習における「探索と活用のトレードオフ」を解決する代表的な方策はどれか。", options: ["バッチ正規化", "ε-greedy方策", "ドロップアウト", "データ拡張"], correct: 1, explanation: "ε-greedy方策は確率εで探索（ランダム行動）、確率1-εで活用（現時点で最良の行動）を行い、探索と活用のバランスを取ります。", keywords: ["ε-greedy方策", "強化学習"] },
      { id: 7, question: "Q学習の説明として最も適切なものはどれか。", options: ["方策を直接最適化する方策勾配法の一種", "行動価値関数Q(s,a)を学習し最大Q値の行動を選択する手法", "オンライン学習が不可能で全エピソード終了後にのみ学習", "連続行動空間の問題に特に適している"], correct: 1, explanation: "Q学習は状態sで行動aを取った時の期待累積報酬を表す行動価値関数Q(s,a)を学習し、各状態でQ値最大の行動を選択します。", keywords: ["Q学習", "行動価値関数"] },
      { id: 8, question: "「実際に病気の人を病気と正しく判定した割合」を表す評価指標はどれか。", options: ["適合率（Precision）", "再現率（Recall）", "正解率（Accuracy）", "F値"], correct: 1, explanation: "再現率（Recall）= TP/(TP+FN)は、実際に陽性のもののうち正しく陽性と予測できた割合で、医療診断では重要な指標です。", keywords: ["再現率", "適合率", "正解率・適合率・再現率・F値"] },
      { id: 9, question: "データをk個に分割し、各分割を順番にテストデータとして使用する検証方法はどれか。", options: ["ホールドアウト検証", "k分割交差検証", "ブートストラップ", "リーブワンアウト"], correct: 1, explanation: "k分割交差検証は、データをk個に分割しk回の学習・評価を行い、その平均性能で評価します。より信頼性の高い評価が可能です。", keywords: ["k-分割交差検証", "交差検証"] },
      { id: 10, question: "主成分分析（PCA）の特徴として最も適切なものはどれか。", options: ["教師あり学習でクラスラベルを考慮して次元削減", "データの分散が最大となる方向を見つけて次元削減する教師なし学習", "非線形関係のデータに特に適している", "元の特徴量の解釈性が向上する"], correct: 1, explanation: "PCAは教師なし学習の次元削減手法で、データの分散が最大となる方向（主成分）を見つけて射影します。", keywords: ["主成分分析 (PCA)", "次元削減"] },
      { id: 11, question: "過学習に関する説明として最も適切なものはどれか。", options: ["訓練データが少なすぎる場合にのみ発生する", "モデルが訓練データに過度に適合し汎化性能が低下する現象", "訓練誤差のみを監視すれば検出可能", "モデルの複雑さを増すことで解決できる"], correct: 1, explanation: "過学習は、モデルが訓練データの特徴やノイズまで「丸暗記」し、未知のデータへの汎化性能が低下する現象です。", keywords: ["過学習", "汎化性能"] },
      { id: 12, question: "ロジスティック回帰の特徴として最も適切なものはどれか。", options: ["名前に「回帰」とあるが主に分類問題に使用される", "連続値の予測に使用され分類には不向き", "ニューラルネットワークの一種で隠れ層を持つ", "非線形分離が可能でSVMの上位互換"], correct: 0, explanation: "ロジスティック回帰は名前に「回帰」とありますが、実際は分類問題に使用され、シグモイド関数で出力を確率値に変換します。", keywords: ["ロジスティック回帰", "分類問題"] },
      { id: 13, question: "混同行列において、実際に陰性のものを陽性と誤って予測した場合を何と呼ぶか。", options: ["真陽性（TP）", "偽陽性（FP）", "真陰性（TN）", "偽陰性（FN）"], correct: 1, explanation: "偽陽性（False Positive, FP）は、実際には陰性であるものを陽性と誤って予測した場合です。", keywords: ["混同行列", "偽陽性・偽陰性", "真陽性・真陰性"] },
      { id: 14, question: "住宅価格の予測モデルを構築する際に使用する手法として最も適切なものはどれか。", options: ["ロジスティック回帰", "k-means法", "線形回帰や重回帰分析", "ナイーブベイズ"], correct: 2, explanation: "住宅価格は連続値であるため回帰問題として定式化し、線形回帰や重回帰分析を用います。", keywords: ["回帰問題", "重回帰分析", "単回帰分析"] },
      { id: 15, question: "過去の自身の値の線形結合で将来値を予測する時系列モデルはどれか。", options: ["ARモデル（自己回帰モデル）", "k-means法", "主成分分析", "ロジスティック回帰"], correct: 0, explanation: "ARモデル（自己回帰モデル）は過去の自身の値の線形結合で将来値を予測します。AR(p)モデルはp期前までの値を使用します。", keywords: ["自己回帰モデル (ARモデル)"] },
      { id: 16, question: "ROC曲線とAUCに関する説明として正しいものはどれか。", options: ["適合率と再現率の関係をプロット", "偽陽性率と真陽性率の関係をプロットしAUCはその曲線下の面積", "AUCが0に近いほど性能が高い", "回帰問題の評価に使用される"], correct: 1, explanation: "ROC曲線は偽陽性率と真陽性率の関係をプロットし、AUC（曲線下面積）は1に近いほど性能が高いことを示します。", keywords: ["ROC曲線・AUC"] },
      { id: 17, question: "複数のモデルを逐次的に学習し、前のモデルの誤差を重点的に学習するアンサンブル手法はどれか。", options: ["バギング", "ブースティング", "スタッキング", "ドロップアウト"], correct: 1, explanation: "ブースティングは弱学習器を逐次的に学習し、前のモデルが誤った予測をしたサンプルに重みをつけて次のモデルを学習します。", keywords: ["ブースティング", "勾配ブースティング"] },
      { id: 18, question: "階層的クラスタリングの結果を可視化するグラフを何と呼ぶか。", options: ["ヒストグラム", "デンドログラム", "散布図", "ROC曲線"], correct: 1, explanation: "階層的クラスタリングの結果はデンドログラム（樹形図）で可視化でき、適切な階層でカットしてクラスタを得ます。", keywords: ["デンドログラム (樹形図)", "ウォード法"] },
      { id: 19, question: "方策を直接パラメータ化し期待報酬を最大化するように更新する強化学習手法はどれか。", options: ["Q学習", "方策勾配法", "バンディットアルゴリズム", "モンテカルロ木探索"], correct: 1, explanation: "方策勾配法は方策π(a|s)を直接パラメータ化し、期待累積報酬の勾配を計算して方策を更新します。REINFORCEが代表例です。", keywords: ["方策勾配法", "REINFORCE", "Actor-Critic"] },
      { id: 20, question: "「同等の説明力を持つならば、より単純な仮説を選ぶべき」という原則を何と呼ぶか。この観点からAICやBICはモデルを評価する。", options: ["バイアス-バリアンストレードオフ", "オッカムの剃刀", "ノーフリーランチの定理", "中心極限定理"], correct: 1, explanation: "オッカムの剃刀は「より単純な仮説を選ぶべき」という原則で、AICやBICはモデルの適合度と複雑さのバランスを評価します。", keywords: ["オッカムの剃刀", "赤池情報量規準 (AIC)", "ベイズ情報量規準 (BIC)"] }
    ]
  },
  chapter3: {
    id: 3, title: "ニューラルネットワーク要素技術", subtitle: "活性化関数・誤差関数・最適化",
    character: "🔙", characterName: "誤差逆伝播の使者", quote: "失敗から学ぶ、それが成長の本質", color: "#f59e0b",
    questions: [
      { id: 1, question: "シグモイド関数やtanh関数を活性化関数として使用した場合に発生しやすい問題と、その解決策として適切な組み合わせはどれか。", options: ["勾配爆発：学習率を大きくする", "勾配消失問題：ReLU関数やその変種を使用", "過学習：より多くの層を追加", "局所最適解：シグモイドの出力範囲を拡大"], correct: 1, explanation: "シグモイド/tanhは入力が大きい領域で勾配がほぼ0になるため勾配消失問題が発生しやすく、ReLUで軽減できます。", keywords: ["勾配消失問題", "ReLU関数", "シグモイド関数"] },
      { id: 2, question: "誤差逆伝播法で使用される微分の連鎖法則を何と呼ぶか。", options: ["積分則", "連鎖律", "合成則", "分配律"], correct: 1, explanation: "連鎖律（chain rule）を用いて出力層から入力層に向かって勾配を効率的に計算します。", keywords: ["誤差逆伝播法", "連鎖律"] },
      { id: 3, question: "多クラス分類問題の出力層で使用され、全クラスの出力合計が1になる活性化関数はどれか。", options: ["ReLU関数", "シグモイド関数", "ソフトマックス関数", "tanh関数"], correct: 2, explanation: "ソフトマックス関数は各クラスの出力を0～1に変換し、合計が1になるため確率として解釈できます。", keywords: ["ソフトマックス関数"] },
      { id: 4, question: "最適化手法Adamの特徴として最も適切なものはどれか。", options: ["SGDそのもので追加機能なし", "モーメンタムと適応的学習率（RMSprop）を組み合わせた手法", "学習率の手動調整が必要", "バッチ学習専用"], correct: 1, explanation: "Adamはモーメンタム（過去の勾配の移動平均）とRMSprop（勾配の二乗の移動平均で学習率を適応調整）を組み合わせています。", keywords: ["Adam", "モーメンタム", "RMSprop"] },
      { id: 5, question: "学習時にランダムにニューロンを無効化し、推論時には全ニューロンを使用する正則化手法はどれか。", options: ["L1正則化", "L2正則化", "ドロップアウト", "バッチ正規化"], correct: 2, explanation: "ドロップアウトは学習時にニューロンを確率的に無効化し、アンサンブル学習のような効果で過学習を防止します。", keywords: ["ドロップアウト", "正則化"] },
      { id: 6, question: "分類問題で使用される交差エントロピー誤差関数の特徴として正しいものはどれか。", options: ["予測値と正解値の差の二乗の平均", "予測した確率分布と正解の確率分布の差を測る指標", "回帰問題に特に適している", "値が大きいほど性能が高い"], correct: 1, explanation: "交差エントロピーは二つの確率分布の違いを測る指標で、分類問題の損失関数として広く使用されます。", keywords: ["交差エントロピー"] },
      { id: 7, question: "L1正則化とL2正則化の違いとして正しいものはどれか。", options: ["L1は全体的に重みを小さくしL2は一部を0にする", "L1は一部の重みを0にする傾向がありL2は全体的に小さくする", "両者は全く同じ効果", "L1は回帰のみL2は分類のみに使用"], correct: 1, explanation: "L1正則化（ラッソ回帰）はスパースな解を得る傾向があり特徴選択の効果が、L2正則化（リッジ回帰）は全体的に重みを小さく保ちます。", keywords: ["L1正則化", "L2正則化", "ラッソ回帰", "リッジ回帰"] },
      { id: 8, question: "データの一部（ミニバッチ）ごとに重みを更新し、効率と安定性のバランスを取る学習方法はどれか。", options: ["バッチ学習", "ミニバッチ学習", "オンライン学習", "転移学習"], correct: 1, explanation: "ミニバッチ学習は、バッチ学習より頻繁に更新でき、SGDより安定した勾配推定が可能です。", keywords: ["ミニバッチ学習", "バッチ学習", "確率的勾配降下法 (SGD)"] },
      { id: 9, question: "学習率の設定に関する説明として正しいものはどれか。", options: ["大きいほど良く最大値に設定すべき", "大きすぎると発散し小さすぎると収束が遅くなる", "一度設定したら変更すべきでない", "0に近いほど良い"], correct: 1, explanation: "学習率が大きすぎると損失関数の最小値を飛び越えて発散し、小さすぎると収束に時間がかかります。", keywords: ["学習率", "ハイパーパラメータ"] },
      { id: 10, question: "全訓練データを1回使い切ることを何と呼ぶか。", options: ["イテレーション", "エポック", "バッチ", "ステップ"], correct: 1, explanation: "1エポックは全訓練データを1回使い切ることを意味し、1イテレーションは1ミニバッチでの1回の重み更新です。", keywords: ["エポック", "イテレーション"] },
      { id: 11, question: "RMSE（二乗平均平方根誤差）の特徴として正しいものはどれか。", options: ["分類問題の主要指標", "MSEの平方根で元のデータと同じ単位で誤差を表現できる", "MSEより外れ値の影響を受けやすい", "常に負の値を取る"], correct: 1, explanation: "RMSE = √MSEで、予測誤差を元のデータと同じ単位で解釈できます。", keywords: ["二乗平均平方根誤差 (RMSE)", "平均二乗誤差 (MSE)"] },
      { id: 12, question: "勾配爆発問題の対策として適切なものはどれか。", options: ["学習率を大きくする", "勾配クリッピングやバッチ正規化", "活性化関数をシグモイドに変更", "層の数を増やす"], correct: 1, explanation: "勾配爆発は勾配が指数的に増大する問題で、勾配クリッピング（勾配の大きさを制限）やバッチ正規化で対策できます。", keywords: ["勾配爆発問題"] },
      { id: 13, question: "二つの確率分布の差異を測る指標で、VAEの損失関数などで使用されるものはどれか。", options: ["平均二乗誤差", "交差エントロピー", "カルバック・ライブラー情報量（KLダイバージェンス）", "コサイン類似度"], correct: 2, explanation: "KLダイバージェンスは確率分布間の差異を測り、VAEでは潜在変数の事後分布と事前分布の差を損失関数の一部として使用します。", keywords: ["カルバック・ライブラー情報量 (KL)"] },
      { id: 14, question: "アンカー、正例、負例の3つのサンプルを使い類似度学習に使用される損失関数はどれか。", options: ["交差エントロピー", "平均二乗誤差", "Triplet Loss", "ヒンジ損失"], correct: 2, explanation: "Triplet Lossはアンカーと正例の距離を小さく、アンカーと負例の距離を大きくするように学習し、顔認識等で使用されます。", keywords: ["Triplet Loss", "Contrastive Loss"] },
      { id: 15, question: "検証誤差が減少しなくなったら学習を停止する手法はどれか。", options: ["正則化", "データ拡張", "早期終了（Early Stopping）", "学習率減衰"], correct: 2, explanation: "早期終了は検証誤差を監視し、改善しなくなった時点で学習を停止して過学習を防止します。", keywords: ["早期終了"] },
      { id: 16, question: "近傍では最小だが大域的には最小とは限らない点を何と呼ぶか。", options: ["大域最適解", "局所最適解", "鞍点", "プラトー"], correct: 1, explanation: "局所最適解は近傍では最小の値を持つが、全体（大域）では最小とは限らない点です。", keywords: ["局所最適解", "大域最適解", "鞍点"] },
      { id: 17, question: "ハイパーパラメータの候補値の全組み合わせを網羅的に探索する手法はどれか。", options: ["ランダムサーチ", "グリッドサーチ", "ベイズ最適化", "進化戦略"], correct: 1, explanation: "グリッドサーチは候補値の格子点を網羅的に探索します。次元数が増えると計算量が爆発的に増加します。", keywords: ["グリッドサーチ", "ランダムサーチ"] },
      { id: 18, question: "モデルの複雑さを増すと誤差が一度上昇した後、再び減少する現象を何と呼ぶか。", options: ["過学習", "二重降下現象", "勾配消失", "バイアス-バリアンストレードオフ"], correct: 1, explanation: "二重降下現象は、モデル複雑さを増すと誤差が減少→上昇→再び減少する現象で、過パラメータ化モデルで観察されます。", keywords: ["二重降下現象"] },
      { id: 19, question: "「すべての問題に対して平均的に最良のアルゴリズムは存在しない」ことを示す定理はどれか。", options: ["中心極限定理", "ベイズの定理", "ノーフリーランチの定理", "大数の法則"], correct: 2, explanation: "ノーフリーランチの定理は、特定の問題に適したアルゴリズム選択の重要性を示します。", keywords: ["ノーフリーランチの定理"] },
      { id: 20, question: "AdaGradの問題点とRMSpropによる改善点として正しいものはどれか。", options: ["学習率が単調減少する問題を指数移動平均で緩和", "RMSpropが累積しAdaGradが移動平均を使用", "両者は同じアルゴリズム", "AdaGradがSGDより常に高性能"], correct: 0, explanation: "AdaGradは過去の勾配の二乗を累積するため学習率が単調減少しますが、RMSpropは指数移動平均でこれを緩和します。", keywords: ["AdaGrad", "RMSprop"] }
    ]
  },
  chapter4: {
    id: 4, title: "ディープラーニング層構造", subtitle: "CNN・RNN・Transformer",
    character: "✨", characterName: "Transformerの申し子", quote: "注意を払うべきものに注意を払え", color: "#8b5cf6",
    questions: [
      { id: 1, question: "畳み込み層の出力サイズを計算する式として正しいものはどれか。（W:入力サイズ、F:フィルタサイズ、S:ストライド、P:パディング）", options: ["W + F - 2P + S", "(W - F + 2P) / S + 1", "W × F × P / S", "(W + F) × (P + S)"], correct: 1, explanation: "出力サイズ = (W - F + 2P) / S + 1で計算されます。パディングで入力サイズを維持できます。", keywords: ["畳み込み層", "ストライド", "パディング"] },
      { id: 2, question: "プーリング層の役割として最も適切なものはどれか。", options: ["特徴マップのサイズを拡大し詳細な特徴を抽出", "特徴マップのサイズを縮小し計算量削減と位置不変性の獲得に寄与", "データの正規化を行い学習を安定化", "活性化関数を適用し非線形性を導入"], correct: 1, explanation: "プーリング層は特徴マップを縮小し、パラメータ数と計算量を削減、位置ずれに対する不変性も得られます。", keywords: ["プーリング層", "最大値プーリング", "不変性の獲得"] },
      { id: 3, question: "ResNetで導入されたスキップ結合の主な効果はどれか。", options: ["計算速度の向上", "勾配消失問題を緩和し100層以上の深いネットワークの学習を可能に", "パラメータ数の削減", "データ拡張の効果"], correct: 1, explanation: "スキップ結合は勾配が直接伝播する経路を作り、深いネットワークでも勾配消失問題を軽減します。", keywords: ["スキップ結合", "ResNet"] },
      { id: 4, question: "バッチ正規化の特徴として最も適切なものはどれか。", options: ["入力データのみに適用され中間層には不適用", "ミニバッチ内のデータを正規化し学習の安定化と高速化に寄与", "推論時にも同じミニバッチの統計量を使用", "ドロップアウトの代替で併用しない"], correct: 1, explanation: "バッチ正規化はミニバッチ内で平均0、分散1に正規化し、学習を安定化・高速化します。", keywords: ["バッチ正規化"] },
      { id: 5, question: "LSTMのゲート機構に関する説明として正しいものはどれか。", options: ["入力ゲート、忘却ゲート、出力ゲートの3種類を持つ", "すべてReLU関数で構成される", "GRUより少ないゲート数で計算効率が良い", "ゲートは学習されず固定"], correct: 0, explanation: "LSTMは入力ゲート、忘却ゲート、出力ゲートの3種類で情報の流れを制御します。", keywords: ["LSTM", "ゲート機構", "GRU"] },
      { id: 6, question: "Transformerアーキテクチャの特徴として最も適切なものはどれか。", options: ["畳み込み層を主要構成要素とする", "再帰結合層を持つ", "Self-Attentionを主要構成要素とし並列計算が可能", "全結合層のみで構成"], correct: 2, explanation: "TransformerはSelf-Attentionのみで系列を処理し、長距離依存関係の学習が容易で並列計算も可能です。", keywords: ["Transformer", "Self-Attention", "Attention"] },
      { id: 7, question: "Self-AttentionにおけるQ、K、Vの役割として正しいものはどれか。", options: ["Qは検索クエリ、Kはインデックス、VはKに対応する値でQとKの類似度でVを重み付け", "Q、K、Vはすべて同じ値", "Qは入力系列、Kは出力系列、Vは損失関数", "Q、K、Vは学習されないハイパーパラメータ"], correct: 0, explanation: "各位置のQと全位置のKの内積（類似度）を計算し、softmaxで正規化後、Vの重み付け和を出力します。", keywords: ["クエリ", "キー", "バリュー", "Self-Attention"] },
      { id: 8, question: "Multi-Head Attentionの特徴として最も適切なものはどれか。", options: ["1つのAttentionを複数回実行し計算量削減", "複数のAttentionを異なる部分空間で並列に計算し多様な表現を学習", "エンコーダのみで使用", "ヘッド数は必ず1"], correct: 1, explanation: "Multi-Head Attentionは複数のAttentionを並列に計算し、異なる種類の関係性を学習できます。", keywords: ["Multi-Head Attention"] },
      { id: 9, question: "Transformerで位置エンコーディングが必要な理由として最も適切なものはどれか。", options: ["計算速度向上のため", "Self-Attentionは位置情報を持たないため単語の順序情報を与える必要がある", "メモリ削減のため", "過学習防止のため"], correct: 1, explanation: "Self-Attentionは入力の順序を考慮しないため、位置エンコーディングで順序情報を与えます。", keywords: ["位置エンコーディング"] },
      { id: 10, question: "オートエンコーダの特徴として最も適切なものはどれか。", options: ["教師あり学習で入力と異なる出力を生成", "入力を圧縮し再構成することで次元削減や特徴学習に使用", "常にデータを高次元空間に写像", "分類問題専用"], correct: 1, explanation: "オートエンコーダは入力を低次元の潜在表現にエンコードし、再構成することで特徴を学習します。", keywords: ["オートエンコーダ", "次元削減"] },
      { id: 11, question: "VAE（変分オートエンコーダ）とオートエンコーダの主な違いとして最も適切なものはどれか。", options: ["VAEは潜在空間を確率分布としてモデル化し生成モデルとして使用可能", "VAEは常に再構成精度が高い", "VAEは教師あり学習", "VAEはCNNベース"], correct: 0, explanation: "VAEは潜在変数を確率分布としてモデル化し、潜在空間からサンプリングして新しいデータを生成できます。", keywords: ["変分オートエンコーダ (VAE)"] },
      { id: 12, question: "RNN（リカレントニューラルネットワーク）の特徴として最も適切なものはどれか。", options: ["各時刻の入力のみ処理し過去情報を保持しない", "隠れ状態で過去の情報を保持し時系列データ処理に適している", "画像処理に特化", "並列計算が容易"], correct: 1, explanation: "RNNは隠れ状態を通じて過去の情報を保持し、時系列データや系列データの処理に適しています。", keywords: ["リカレントニューラルネットワーク (RNN)", "時系列データ"] },
      { id: 13, question: "双方向RNN（Bidirectional RNN）の特徴として最も適切なものはどれか。", options: ["順方向と逆方向の2つのRNNを持ち過去と未来両方のコンテキストを考慮可能", "通常のRNNの2倍の速度で学習", "リアルタイム処理に適している", "メモリ使用量が通常のRNNより少ない"], correct: 0, explanation: "双方向RNNは順方向と逆方向の2つのRNNを持ち、各時刻で過去と未来両方のコンテキストを考慮できます。", keywords: ["双方向RNN (Bidirectional RNN)"] },
      { id: 14, question: "系列生成モデルの学習時にデコーダの各ステップで正解系列を入力として与える手法はどれか。", options: ["ドロップアウト", "教師強制（Teacher Forcing）", "データ拡張", "正則化"], correct: 1, explanation: "教師強制は学習時にデコーダに正解系列を入力として与え、学習を安定・高速化しますが、学習時と推論時のギャップが生じる課題もあります。", keywords: ["教師強制", "Seq2Seq"] },
      { id: 15, question: "レイヤー正規化とバッチ正規化の違いとして最も適切なものはどれか。", options: ["レイヤー正規化はバッチ方向に正規化", "レイヤー正規化は各サンプルの特徴方向に正規化しバッチサイズに依存しないためRNNやTransformerで使用", "CNN専用とRNN専用", "両者は同じ手法"], correct: 1, explanation: "レイヤー正規化は各サンプル内の特徴方向で正規化し、バッチサイズに依存しないためRNN、Transformerで有効です。", keywords: ["レイヤー正規化", "バッチ正規化"] },
      { id: 16, question: "Depthwise Separable Convolutionの特徴として最も適切なものはどれか。", options: ["通常の畳み込みより計算量が多い", "深さ方向と点方向の畳み込みに分解し計算量を削減", "全結合層の代替", "3D畳み込みの別名"], correct: 1, explanation: "Depthwise Separable Convolutionは畳み込みを分解して計算量を大幅に削減し、MobileNetなどで使用されます。", keywords: ["Depthwise Separable Convolution"] },
      { id: 17, question: "Dilated Convolution（Atrous Convolution）の特徴として最も適切なものはどれか。", options: ["フィルタ要素間に間隔を設けパラメータ数を増やさずに受容野を拡大", "フィルタ要素間に間隔を設け計算量を増加", "プーリング層の代替で解像度を低下", "1×1フィルタのみで構成"], correct: 0, explanation: "Dilated Convolutionはフィルタの要素間に間隔を設け、パラメータ数を増やさずに受容野を拡大できます。", keywords: ["Dilated Convolution", "Atrous Convolution"] },
      { id: 18, question: "BPTT（Backpropagation Through Time）の説明として最も適切なものはどれか。", options: ["CNNの学習に使用される手法", "RNNを時間方向に展開し通常の誤差逆伝播法を適用する手法", "バッチ処理を時間方向に分割", "Attentionの計算に使用"], correct: 1, explanation: "BPTTはRNNを時間方向に展開し、展開されたネットワークに誤差逆伝播法を適用します。", keywords: ["BPTT"] },
      { id: 19, question: "Seq2Seqモデルの特徴として最も適切なものはどれか。", options: ["入力と出力の長さが同じ必要がある", "エンコーダとデコーダからなり可変長の入力を可変長の出力に変換可能", "分類問題専用", "Attentionを使用できない"], correct: 1, explanation: "Seq2Seqはエンコーダが入力系列をコンテキストベクトルに変換し、デコーダが出力系列を生成します。機械翻訳等で使用されます。", keywords: ["Seq2Seq"] },
      { id: 20, question: "Source-Target Attention（Cross Attention）の特徴として最も適切なものはどれか。", options: ["同じ系列内の要素間の関係を計算", "Qがデコーダから、K,Vがエンコーダから来て異なる系列間の対応を学習", "Self-Attentionの別名", "Transformerでは不使用"], correct: 1, explanation: "Source-Target Attentionは、デコーダの各位置がエンコーダ出力のどこに注目すべきかを計算します。", keywords: ["Source-Target Attention"] }
    ]
  },
  chapter5: {
    id: 5, title: "ディープラーニング応用", subtitle: "画像・自然言語・音声・生成",
    character: "👁️", characterName: "応用の達人", quote: "理論を実践に、実践を価値に", color: "#ec4899",
    questions: [
      { id: 1, question: "物体検出手法YOLOの特徴として最も適切なものはどれか。", options: ["画像を複数回スキャンし段階的に検出", "画像全体を一度見るだけで検出しリアルタイム処理が可能", "2段階検出でFaster R-CNNより高精度", "セマンティックセグメンテーション専用"], correct: 1, explanation: "YOLO（You Only Look Once）は画像を一度見るだけで物体のクラスと位置を同時に予測し、高速でリアルタイム処理が可能です。", keywords: ["YOLO", "物体検出"] },
      { id: 2, question: "セマンティックセグメンテーションとインスタンスセグメンテーションの違いとして正しいものはどれか。", options: ["3Dと2Dの違い", "セマンティックは各ピクセルのクラス予測、インスタンスは同クラスの個体も区別", "画像全体の分類と物体検出の違い", "両者は同じタスク"], correct: 1, explanation: "セマンティックセグメンテーションは各ピクセルのクラスを予測し、インスタンスセグメンテーションは同クラスでも個体を区別します。", keywords: ["セマンティックセグメンテーション", "インスタンスセグメンテーション"] },
      { id: 3, question: "word2vecの特徴として最も適切なものはどれか。", options: ["単語をone-hotベクトルで表現", "単語を密な低次元ベクトル（分散表現）で表現し意味的類似性を距離で表現可能", "Transformerベースの言語モデル", "文書分類専用"], correct: 1, explanation: "word2vecは単語を密なベクトルで表現し、「king - man + woman ≈ queen」のような意味的演算が可能です。", keywords: ["word2vec", "分散表現", "単語埋め込み", "CBOW", "スキップグラム"] },
      { id: 4, question: "BERTの特徴として最も適切なものはどれか。", options: ["左から右への一方向のみで文脈を考慮", "マスク言語モデルで事前学習され双方向の文脈を考慮可能", "画像生成専用", "GPTの後継で同じ学習タスク"], correct: 1, explanation: "BERTはマスク言語モデル（MLM）で事前学習され、双方向の文脈を考慮できます。", keywords: ["BERT"] },
      { id: 5, question: "GPTシリーズの特徴として最も適切なものはどれか。", options: ["マスク言語モデルで学習", "次の単語を予測するタスクで事前学習されテキスト生成に適している", "Transformerのエンコーダのみ使用", "小規模モデルでLLMに非該当"], correct: 1, explanation: "GPTは次の単語を予測する自己回帰言語モデルで事前学習され、Transformerのデコーダを使用します。", keywords: ["GPT-n", "ChatGPT", "大規模言語モデル(LLM)"] },
      { id: 6, question: "GAN（敵対的生成ネットワーク）の特徴として最も適切なものはどれか。", options: ["生成器と識別器が協力して学習", "生成器と識別器が敵対的に学習し生成器はリアルなデータを生成するように学習", "オートエンコーダの一種", "教師あり学習で正解ラベルが必要"], correct: 1, explanation: "GANは生成器と識別器が敵対的に学習し、生成器はリアルなデータを生成、識別器は本物と偽物を区別するように学習します。", keywords: ["敵対的生成ネットワーク (GAN)"] },
      { id: 7, question: "Diffusion Model（拡散モデル）の特徴として最も適切なものはどれか。", options: ["生成器と識別器の敵対的学習", "データにノイズを徐々に加える過程を学習しノイズ除去の逆過程で画像を生成", "VAEの一種", "自己回帰モデルでピクセルを順番に生成"], correct: 1, explanation: "Diffusion Modelはノイズを徐々に加える拡散過程と、ノイズ除去の逆拡散過程を学習し、高品質な画像を生成します。", keywords: ["Diffusion Model"] },
      { id: 8, question: "RLHF（Reinforcement Learning from Human Feedback）の特徴として最も適切なものはどれか。", options: ["教師あり学習のみで言語モデルを学習", "人間のフィードバックを報酬として強化学習を行い言語モデルを人間の好みに調整", "画像認識専用", "大量のラベル付きデータが必要"], correct: 1, explanation: "RLHFは人間の評価を報酬として使用し、言語モデルを人間の好みや価値観に合わせて調整します。", keywords: ["RLHF"] },
      { id: 9, question: "転移学習とファインチューニングの違いとして正しいものはどれか。", options: ["両者は同じ手法", "転移学習は事前学習モデルの知識活用の概念、ファインチューニングは重みを新タスクで更新する具体的手法", "小規模データと大規模データの違い", "ファインチューニングは事前学習モデル不使用"], correct: 1, explanation: "転移学習は知識活用の概念で、ファインチューニングは事前学習済みモデルの重みを新タスクのデータで追加学習する手法です。", keywords: ["転移学習", "ファインチューニング", "事前学習済みモデル"] },
      { id: 10, question: "マルチモーダル学習の特徴として最も適切なものはどれか。", options: ["複数言語の同時学習", "テキスト、画像、音声など複数種類のデータを統合して処理する学習", "複数GPUで並列学習", "マルチタスク学習と同義"], correct: 1, explanation: "マルチモーダル学習はテキスト、画像、音声など異なる種類のデータを統合して処理・学習します。", keywords: ["マルチモーダル", "CLIP", "DALL-E"] },
      { id: 11, question: "説明可能AI（XAI）の手法Grad-CAMの特徴として最も適切なものはどれか。", options: ["モデルの出力に対する入力ピクセルの勾配を可視化", "特徴マップに対する出力の勾配を使ってCNNの判断に重要な領域を可視化", "モデルの重みを直接可視化", "自然言語処理専用"], correct: 1, explanation: "Grad-CAMは特徴マップに対する勾配を使って、CNNの判断に重要な領域をヒートマップで可視化します。", keywords: ["Grad-CAM", "CAM", "説明可能AI (XAI)"] },
      { id: 12, question: "モデル軽量化手法の蒸留（Knowledge Distillation）の特徴として最も適切なものはどれか。", options: ["大きなモデルの重みを直接小さなモデルにコピー", "大きな教師モデルの出力（ソフトラベル）を使って小さな生徒モデルを学習", "不要なニューロンを削除", "重みの精度を下げて軽量化"], correct: 1, explanation: "蒸留は教師モデルのソフトラベル（確率出力）を使って生徒モデルを学習させ、知識を転移します。", keywords: ["蒸留"] },
      { id: 13, question: "DQN（Deep Q-Network）の特徴として最も適切なものはどれか。", options: ["Q学習とCNNを組み合わせ画像入力から直接行動価値を推定", "教師あり学習で正解ラベルが必要", "GANの一種", "BERTの別名"], correct: 0, explanation: "DQNはQ学習とCNNを組み合わせた深層強化学習手法で、Atariゲームで人間超えの性能を達成しました。", keywords: ["DQN", "深層強化学習"] },
      { id: 14, question: "音声認識で使用されるMFCC（メル周波数ケプストラム係数）の特徴として最も適切なものはどれか。", options: ["音声波形をそのまま使用", "人間の聴覚特性を模倣したメル尺度に基づく音声の特徴量", "画像認識専用", "ディープラーニング以降は不使用"], correct: 1, explanation: "MFCCは人間の聴覚特性を模倣したメル尺度に基づく音声の特徴量で、現在も広く使用されています。", keywords: ["メル周波数ケプストラム係数 (MFCC)", "メル尺度"] },
      { id: 15, question: "自己教師あり学習（Self-Supervised Learning）の特徴として最も適切なものはどれか。", options: ["人間がラベルを付与したデータで学習", "データ自体から疑似的なラベルを生成し大量の未ラベルデータで事前学習", "強化学習の一種で報酬信号を使用", "クラスタリングと同じ手法"], correct: 1, explanation: "自己教師あり学習はデータ自体から疑似的な教師信号を生成して学習し、大量の未ラベルデータを活用できます。", keywords: ["自己教師あり学習"] },
      { id: 16, question: "Vision Transformer（ViT）の特徴として最も適切なものはどれか。", options: ["画像をパッチに分割しTransformerのエンコーダで処理", "CNNとRNNを組み合わせ", "動画専用", "CNNより常に低性能"], correct: 0, explanation: "ViTは画像を固定サイズのパッチに分割し、Transformerのエンコーダで処理する画像認識モデルです。", keywords: ["Vision Transformer"] },
      { id: 17, question: "Few-shot学習の特徴として最も適切なものはどれか。", options: ["大量のラベル付きデータが必要", "各クラスに少数のサンプルのみで新タスクに適応する学習方法", "ゼロから学習し事前学習は不使用", "教師なし学習の一種"], correct: 1, explanation: "Few-shot学習は各クラスに少数のサンプルのみで新タスクに適応できるようにする学習方法です。", keywords: ["Few-shot", "One-shot", "Zero-shot"] },
      { id: 18, question: "破壊的忘却（Catastrophic Forgetting）の説明として最も適切なものはどれか。", options: ["モデルが学習データを記憶できない", "新タスク学習時に以前のタスクの性能が急激に低下する現象", "過学習の別名", "データ不足時のみ発生"], correct: 1, explanation: "破壊的忘却は新タスクを学習すると以前のタスクで学習した知識を急激に失ってしまう現象です。", keywords: ["破壊的忘却"] },
      { id: 19, question: "基盤モデル（Foundation Model）の特徴として最も適切なものはどれか。", options: ["特定タスク専用の小規模モデル", "大規模データで事前学習され様々な下流タスクに適応できる汎用的な大規模モデル", "画像処理専用", "ファインチューニング不可"], correct: 1, explanation: "基盤モデルは大規模データで事前学習され、様々な下流タスクに適応できる汎用的な大規模モデルです。", keywords: ["基盤モデル"] },
      { id: 20, question: "CTC（Connectionist Temporal Classification）の特徴として最も適切なものはどれか。", options: ["入力と出力の長さが同じ必要がある", "入力と出力の長さが異なっても明示的なアライメントなしに系列ラベリングを学習可能", "画像分類専用", "GANの学習に使用"], correct: 1, explanation: "CTCは入力系列と出力系列の明示的なアライメントなしに系列ラベリングを学習でき、音声認識等で使用されます。", keywords: ["CTC"] }
    ]
  },
  chapter6: {
    id: 6, title: "AIプロジェクトとデータ", subtitle: "開発プロセスと実装",
    character: "🗺️", characterName: "プロジェクトの指揮官", quote: "計画なき実装は、実装なき計画に等しい", color: "#14b8a6",
    questions: [
      { id: 1, question: "CRISP-DMの6つのフェーズの正しい順序はどれか。", options: ["データ準備→ビジネス理解→データ理解→モデリング→評価→展開", "ビジネス理解→データ理解→データ準備→モデリング→評価→展開", "モデリング→データ準備→評価→ビジネス理解→データ理解→展開", "展開→評価→モデリング→データ準備→データ理解→ビジネス理解"], correct: 1, explanation: "CRISP-DMは、ビジネス理解→データ理解→データ準備→モデリング→評価→展開の6フェーズで、反復的に進めます。", keywords: ["CRISP-DM"] },
      { id: 2, question: "PoC（Proof of Concept）の説明として最も適切なものはどれか。", options: ["本番環境でのAIシステム運用", "本格開発前に技術的・ビジネス的な実現可能性を検証する段階", "最終的な製品のリリース", "プロジェクト完了後の保守フェーズ"], correct: 1, explanation: "PoCは本格開発前に、そのアイデアや技術が実現可能かどうかを小規模に検証する段階です。", keywords: ["PoC"] },
      { id: 3, question: "MLOpsの説明として最も適切なものはどれか。", options: ["機械学習の理論研究", "機械学習モデルの開発・デプロイ・運用を効率化するための手法やツール", "データの可視化ツール", "ハードウェアの最適化"], correct: 1, explanation: "MLOpsは機械学習のライフサイクル全体（開発、デプロイ、運用、モニタリング）を効率化する手法です。", keywords: ["MLOps"] },
      { id: 4, question: "データにラベルを付与する作業を何と呼ぶか。", options: ["クレンジング", "アノテーション", "正規化", "特徴量エンジニアリング"], correct: 1, explanation: "アノテーションは教師あり学習に必要な正解ラベルをデータに付与する作業です。", keywords: ["アノテーション"] },
      { id: 5, question: "学習時に本来知り得ないはずの情報が混入する問題を何と呼ぶか。", options: ["過学習", "データリーケージ", "サンプリングバイアス", "ラベルノイズ"], correct: 1, explanation: "データリーケージはテストデータの情報が学習に混入する問題で、評価が不正確になります。", keywords: ["データリーケージ"] },
      { id: 6, question: "自然言語処理のための大規模なテキストデータ集を何と呼ぶか。", options: ["データセット", "コーパス", "アーカイブ", "リポジトリ"], correct: 1, explanation: "コーパスは自然言語処理の学習や評価に使用される大規模なテキストデータ集です。", keywords: ["コーパス"] },
      { id: 7, question: "Pythonで広く使われている対話型の開発環境はどれか。", options: ["Visual Studio Code", "Jupyter Notebook", "Eclipse", "Vim"], correct: 1, explanation: "Jupyter Notebookはコード、説明文、可視化を一つの文書で管理できる対話型開発環境です。", keywords: ["Jupyter Notebook"] },
      { id: 8, question: "アプリケーションとその実行環境をパッケージ化する技術はどれか。", options: ["仮想マシン", "Docker", "Kubernetes", "サーバレス"], correct: 1, explanation: "Dockerはコンテナ技術で、アプリケーションと環境をパッケージ化し再現性を高めます。", keywords: ["Docker"] },
      { id: 9, question: "モデルをAPIとして公開し外部からアクセス可能にする方式はどれか。", options: ["バッチ処理", "Web API", "ストリーミング", "エッジデプロイ"], correct: 1, explanation: "Web APIはHTTPリクエストでモデルの推論結果を取得できる方式です。", keywords: ["Web API"] },
      { id: 10, question: "短いサイクルで反復的に開発を進める手法はどれか。", options: ["ウォーターフォール", "アジャイル", "スパイラル", "プロトタイピング"], correct: 1, explanation: "アジャイル開発は短いイテレーションで要件変更に柔軟に対応する開発手法です。", keywords: ["アジャイル"] },
      { id: 11, question: "要件定義から順番に進め、前の工程に戻らない開発手法はどれか。", options: ["アジャイル", "ウォーターフォール", "スクラム", "カンバン"], correct: 1, explanation: "ウォーターフォール開発は各工程を順番に進め、基本的に前の工程に戻らない手法です。", keywords: ["ウォーターフォール"] },
      { id: 12, question: "AIのビジネス活用で最も重要な最初のステップはどれか。", options: ["データ収集", "モデル選定", "課題の明確化", "ツール選定"], correct: 2, explanation: "AI導入の前に、解決すべきビジネス課題を明確にすることが成功の鍵です。", keywords: ["AIのビジネス活用"] },
      { id: 13, question: "インターネット経由でコンピューティングリソースを提供するサービスを何と呼ぶか。", options: ["オンプレミス", "クラウド", "ハイブリッド", "エッジ"], correct: 1, explanation: "クラウドは必要なリソースを必要な時にインターネット経由で利用できるサービスです。", keywords: ["クラウド"] },
      { id: 14, question: "企業の業務プロセスを根本から見直し再設計することを何と呼ぶか。", options: ["DX", "BPR", "ERP", "SCM"], correct: 1, explanation: "BPR（Business Process Re-engineering）は業務プロセスの抜本的な見直しです。", keywords: ["BPR"] },
      { id: 15, question: "大学や研究機関と企業が共同で研究開発を行うことを何と呼ぶか。", options: ["オープンイノベーション", "産学連携", "コンソーシアム", "JV"], correct: 1, explanation: "産学連携は学術機関の研究成果を実用化するために重要な取り組みです。", keywords: ["産学連携"] },
      { id: 16, question: "外部のアイデアや技術を活用してイノベーションを生み出す考え方を何と呼ぶか。", options: ["クローズドイノベーション", "オープンイノベーション", "リバースイノベーション", "破壊的イノベーション"], correct: 1, explanation: "オープンイノベーションは社内外の知識を組み合わせて新しい価値を創出する考え方です。", keywords: ["オープン・イノベーション"] },
      { id: 17, question: "統計学、プログラミング、ドメイン知識を活かしてデータから価値を創出する専門家を何と呼ぶか。", options: ["データエンジニア", "データサイエンティスト", "MLエンジニア", "ビジネスアナリスト"], correct: 1, explanation: "データサイエンティストはデータ分析からモデル構築まで行い、ビジネス価値を創出します。", keywords: ["データサイエンティスト"] },
      { id: 18, question: "誰でも自由に利用できる公開されたデータセットを何と呼ぶか。", options: ["プロプライエタリデータ", "オープンデータセット", "合成データ", "匿名データ"], correct: 1, explanation: "オープンデータセットは研究や開発のために公開されているデータセットです。", keywords: ["オープンデータセット"] },
      { id: 19, question: "AIシステムをサービスやプロダクトとして世に出す際に特に注意すべきことはどれか。", options: ["開発速度の最大化", "ステークホルダーのニーズの理解と対応", "最新技術の採用", "コスト削減"], correct: 1, explanation: "ステークホルダーのニーズを理解することで、AIプロジェクトの価値を最大化できます。", keywords: ["ステークホルダーのニーズ"] },
      { id: 20, question: "AIの運用において、モデルの性能監視やライフサイクル管理を行う際に重要な概念はどれか。", options: ["CRISP-DM", "MLOps", "PMBOK", "ITIL"], correct: 1, explanation: "MLOpsはモデルのヘルスモニタリングやライフサイクル管理を含む、ML運用の効率化手法です。", keywords: ["MLOps"] }
    ]
  },
  chapter7: {
    id: 7, title: "数理・統計知識", subtitle: "AIに必要な数学基礎",
    character: "📊", characterName: "統計の長老", quote: "平均だけを見るな、ばらつきの中に真実がある", color: "#0ea5e9",
    questions: [
      { id: 1, question: "データの総和を個数で割った値を何と呼ぶか。", options: ["中央値", "最頻値", "平均", "分散"], correct: 2, explanation: "平均はデータの代表値として最も基本的な指標です。", keywords: ["平均"] },
      { id: 2, question: "データを小さい順に並べた時、中央に位置する値を何と呼ぶか。", options: ["平均", "中央値", "最頻値", "分散"], correct: 1, explanation: "中央値は外れ値の影響を受けにくい代表値です。", keywords: ["中央値"] },
      { id: 3, question: "偏差の二乗の平均を何と呼ぶか。", options: ["標準偏差", "分散", "共分散", "範囲"], correct: 1, explanation: "分散は各データが平均からどれだけ離れているかを示す指標です。", keywords: ["分散"] },
      { id: 4, question: "分散の平方根を取った値を何と呼ぶか。", options: ["分散", "標準偏差", "共分散", "偏差"], correct: 1, explanation: "標準偏差は元のデータと同じ単位で散らばりを表現できます。", keywords: ["標準偏差"] },
      { id: 5, question: "平均を中心に左右対称な釣鐘型の分布を何と呼ぶか。", options: ["一様分布", "正規分布", "ポアソン分布", "指数分布"], correct: 1, explanation: "正規分布は自然界や社会現象の多くで見られる重要な分布です。", keywords: ["正規分布"] },
      { id: 6, question: "成功か失敗かの2値を取る1回の試行の分布を何と呼ぶか。", options: ["正規分布", "二項分布", "ベルヌーイ分布", "ポアソン分布"], correct: 2, explanation: "ベルヌーイ分布は1回の試行で成功か失敗かの2値を取る分布です。", keywords: ["ベルヌーイ分布"] },
      { id: 7, question: "n回のベルヌーイ試行における成功回数の分布を何と呼ぶか。", options: ["ベルヌーイ分布", "二項分布", "ポアソン分布", "幾何分布"], correct: 1, explanation: "二項分布はn回の独立したベルヌーイ試行における成功回数の分布です。", keywords: ["二項分布"] },
      { id: 8, question: "単位時間あたりに発生する稀な事象の回数を表す分布を何と呼ぶか。", options: ["正規分布", "二項分布", "ポアソン分布", "指数分布"], correct: 2, explanation: "ポアソン分布は一定期間内に発生する稀な事象の回数をモデル化します。", keywords: ["ポアソン分布"] },
      { id: 9, question: "2つの変数の線形な関係の強さを-1から1で表す指標を何と呼ぶか。", options: ["共分散", "相関係数", "回帰係数", "決定係数"], correct: 1, explanation: "相関係数は2変数の線形な関係の強さと方向を示します。", keywords: ["相関係数"] },
      { id: 10, question: "直接の因果関係がないのに相関があるように見える現象を何と呼ぶか。", options: ["因果関係", "疑似相関", "逆因果", "多重共線性"], correct: 1, explanation: "疑似相関は第3の変数が原因で相関があるように見える現象です。", keywords: ["疑似相関"] },
      { id: 11, question: "2点間の直線距離を何と呼ぶか。", options: ["マンハッタン距離", "ユークリッド距離", "コサイン類似度", "マハラノビス距離"], correct: 1, explanation: "ユークリッド距離は2点間の直線距離です。", keywords: ["ユークリッド距離"] },
      { id: 12, question: "2つのベクトルの向きの近さを測る指標を何と呼ぶか。", options: ["ユークリッド距離", "マンハッタン距離", "コサイン類似度", "ジャッカード係数"], correct: 2, explanation: "コサイン類似度はベクトルの向きの類似性を測ります。", keywords: ["コサイン類似度"] },
      { id: 13, question: "データの分布の形状を考慮した距離を何と呼ぶか。", options: ["ユークリッド距離", "マンハッタン距離", "マハラノビス距離", "ハミング距離"], correct: 2, explanation: "マハラノビス距離は共分散を考慮した距離です。", keywords: ["マハラノビス距離"] },
      { id: 14, question: "事象Aが起きた条件のもとで事象Bが起きる確率を何と呼ぶか。", options: ["同時確率", "周辺確率", "条件付き確率", "事前確率"], correct: 2, explanation: "条件付き確率P(B|A)は、Aが起きたときにBが起きる確率です。", keywords: ["条件付き確率"] },
      { id: 15, question: "観測データから事前確率を更新して事後確率を求める定理を何と呼ぶか。", options: ["大数の法則", "中心極限定理", "ベイズの定理", "全確率の定理"], correct: 2, explanation: "ベイズの定理はP(A|B) = P(B|A)P(A)/P(B)で事後確率を計算します。", keywords: ["ベイズの定理"] },
      { id: 16, question: "確率変数の取りうる値とその確率の積の総和を何と呼ぶか。", options: ["分散", "期待値", "最頻値", "中央値"], correct: 1, explanation: "期待値は確率変数の平均的な値を表します。", keywords: ["期待値"] },
      { id: 17, question: "統計的検定において「差がない」という仮説を何と呼ぶか。", options: ["対立仮説", "帰無仮説", "検定仮説", "実験仮説"], correct: 1, explanation: "帰無仮説は「効果がない」「差がない」という否定したい仮説です。", keywords: ["帰無仮説", "対立仮説"] },
      { id: 18, question: "誤差の二乗の合計を最小化してパラメータを推定する方法を何と呼ぶか。", options: ["最尤法", "最小二乗法", "モーメント法", "ベイズ推定"], correct: 1, explanation: "最小二乗法は回帰分析などで広く使われるパラメータ推定法です。", keywords: ["最小二乗法"] },
      { id: 19, question: "データが得られる確率（尤度）を最大化するパラメータを求める方法を何と呼ぶか。", options: ["最小二乗法", "最尤法", "ベイズ推定", "モーメント法"], correct: 1, explanation: "最尤法は観測データの尤度を最大化するパラメータを推定します。", keywords: ["最尤法"] },
      { id: 20, question: "時系列データのトレンドを滑らかにするために直近のデータの平均を使う方法を何と呼ぶか。", options: ["指数平滑法", "移動平均", "差分", "自己相関"], correct: 1, explanation: "移動平均は一定期間のデータの平均を取り、ノイズを除去します。", keywords: ["移動平均"] }
    ]
  },
  chapter8: {
    id: 8, title: "法律と契約", subtitle: "AI開発の法的側面",
    character: "🔒", characterName: "法の守護者", quote: "データは力だ、だからこそ守らねばならない", color: "#f97316",
    questions: [
      { id: 1, question: "生存する個人に関する情報で、特定の個人を識別できるものを何と呼ぶか。", options: ["個人データ", "個人情報", "保有個人データ", "要配慮個人情報"], correct: 1, explanation: "個人情報は氏名、生年月日など特定の個人を識別できる情報です。", keywords: ["個人情報"] },
      { id: 2, question: "指紋や顔認証データなど、個人を識別するための符号を何と呼ぶか。", options: ["個人情報", "個人識別符号", "要配慮個人情報", "仮名加工情報"], correct: 1, explanation: "個人識別符号はDNA、指紋、顔認証データ、マイナンバーなどを指します。", keywords: ["個人識別符号"] },
      { id: 3, question: "人種、信条、病歴など、不当な差別につながりうる情報を何と呼ぶか。", options: ["個人情報", "個人識別符号", "要配慮個人情報", "機微情報"], correct: 2, explanation: "要配慮個人情報は取得に本人同意が必要な、特に慎重な取り扱いが求められる情報です。", keywords: ["要配慮個人情報"] },
      { id: 4, question: "個人情報を加工して、復元できないようにしたものを何と呼ぶか。", options: ["仮名加工情報", "匿名加工情報", "個人データ", "統計情報"], correct: 1, explanation: "匿名加工情報は復元できないように加工され、本人同意なく第三者提供が可能です。", keywords: ["匿名加工情報"] },
      { id: 5, question: "他の情報と照合すれば特定できる状態で、氏名などを削除した情報を何と呼ぶか。", options: ["匿名加工情報", "仮名加工情報", "統計情報", "要配慮個人情報"], correct: 1, explanation: "仮名加工情報は内部分析には使えますが、第三者提供は原則禁止です。", keywords: ["仮名加工情報"] },
      { id: 6, question: "EUの個人データ保護に関する法律を何と呼ぶか。", options: ["CCPA", "GDPR", "HIPAA", "PIPEDA"], correct: 1, explanation: "GDPRはEU市民のデータを扱う企業に適用される厳格な規則です。", keywords: ["GDPR"] },
      { id: 7, question: "思想・感情を創作的に表現したものを何と呼ぶか。", options: ["発明", "著作物", "商標", "意匠"], correct: 1, explanation: "著作物は創作性のある表現であり、著作権法で保護されます。", keywords: ["著作物", "創作性"] },
      { id: 8, question: "著作権法30条の4で認められている、情報解析のための著作物利用について正しいものはどれか。", options: ["商業利用は禁止", "著作権者の許諾なく利用可能", "複製配布も自由", "翻訳出版も可能"], correct: 1, explanation: "30条の4は情報解析のための著作物利用を著作権者の許諾なく認めています。", keywords: ["著作権法30条4"] },
      { id: 9, question: "AIが生成したコンテンツの著作権について、現状の考え方として正しいものはどれか。", options: ["AIに著作権が発生", "開発者に著作権が発生", "人間の創作的寄与がなければ著作権は発生しない", "利用者に自動的に著作権発生"], correct: 2, explanation: "AI生成物に著作権が発生するかは、人間の創作的関与の程度によります。", keywords: ["AI生成物"] },
      { id: 10, question: "自然法則を利用した技術的思想の創作のうち高度なものを何と呼ぶか。", options: ["著作物", "発明", "商標", "意匠"], correct: 1, explanation: "発明は新規性と進歩性があれば特許として保護されます。", keywords: ["発明", "新規性", "進歩性"] },
      { id: 11, question: "従業員が職務上行った発明を何と呼ぶか。", options: ["共同発明", "職務発明", "自由発明", "改良発明"], correct: 1, explanation: "職務発明は会社の業務範囲内で従業員が行った発明です。", keywords: ["職務発明"] },
      { id: 12, question: "秘密として管理され、事業活動に有用で、公然と知られていない情報を何と呼ぶか。", options: ["個人情報", "営業秘密", "限定提供データ", "特許"], correct: 1, explanation: "営業秘密は秘密管理性、有用性、非公知性の3要件を満たす必要があります。", keywords: ["営業秘密"] },
      { id: 13, question: "特定の者に提供される、相当量蓄積されたデータを何と呼ぶか。", options: ["営業秘密", "個人情報", "限定提供データ", "オープンデータ"], correct: 2, explanation: "限定提供データは2019年の不正競争防止法改正で保護対象となりました。", keywords: ["限定提供データ"] },
      { id: 14, question: "AI開発の契約形態として、成果物の完成を約束するものを何と呼ぶか。", options: ["準委任契約", "請負契約", "派遣契約", "ライセンス契約"], correct: 1, explanation: "請負契約は成果物の完成義務があります。", keywords: ["請負契約"] },
      { id: 15, question: "AI開発の契約形態として、善管注意義務をもって業務を行うものを何と呼ぶか。", options: ["請負契約", "準委任契約", "売買契約", "賃貸借契約"], correct: 1, explanation: "準委任契約は成果物の完成義務はなく、業務遂行に善管注意義務を負います。", keywords: ["準委任契約"] },
      { id: 16, question: "機密情報の取り扱いについて定める契約を何と呼ぶか。", options: ["ライセンス契約", "NDA", "SLA", "保守契約"], correct: 1, explanation: "NDA（秘密保持契約）はAI開発で共有するデータやノウハウの機密保持を定めます。", keywords: ["NDA"] },
      { id: 17, question: "AIモデルの精度を契約で保証することについて、一般的に正しい認識はどれか。", options: ["100%の精度保証が標準", "精度保証は容易で一般的", "精度保証は困難で期待値のすり合わせが重要", "精度保証は法律で義務付け"], correct: 2, explanation: "AIの精度は環境やデータに依存するため、保証は困難です。", keywords: ["精度保証"] },
      { id: 18, question: "クラウドでAIサービスを提供する形態を何と呼ぶか。", options: ["IaaS", "PaaS", "SaaS", "オンプレミス"], correct: 2, explanation: "SaaS型のAIサービスは、ユーザーがインフラを意識せずAI機能を利用できます。", keywords: ["SaaS"] },
      { id: 19, question: "AIサービスの利用条件を定めた契約文書を何と呼ぶか。", options: ["NDA", "SLA", "利用規約", "プライバシーポリシー"], correct: 2, explanation: "利用規約はサービス利用のルール、禁止事項、責任の範囲などを定めます。", keywords: ["利用規約"] },
      { id: 20, question: "市場における公正な競争を阻害する行為を規制する法律は何か。", options: ["著作権法", "個人情報保護法", "独占禁止法", "不正競争防止法"], correct: 2, explanation: "独占禁止法はカルテルや不当な取引制限など、競争を阻害する行為を規制します。", keywords: ["独占禁止法"] }
    ]
  },
  chapter9: {
    id: 9, title: "AI倫理・ガバナンス", subtitle: "責任あるAI開発",
    character: "⚖️", characterName: "倫理の番人", quote: "技術は中立ではない、作る者の価値観が結果に現れる", color: "#dc2626",
    questions: [
      { id: 1, question: "AIシステムが持つべき価値観や原則を定めたものを何と呼ぶか。", options: ["AI規制", "AI倫理", "AIガバナンス", "AI監査"], correct: 1, explanation: "AI倫理は公平性、透明性、説明責任などの原則を含みます。", keywords: ["AI倫理"] },
      { id: 2, question: "AIのリスクに応じて規制の強度を変える考え方を何と呼ぶか。", options: ["ゼロトレランス", "リスクベースアプローチ", "予防原則", "自主規制"], correct: 1, explanation: "リスクベースアプローチは、高リスクAIには厳しく、低リスクAIには緩やかな規制を適用します。", keywords: ["リスクベースアプローチ"] },
      { id: 3, question: "法的拘束力のないガイドラインや規範を何と呼ぶか。", options: ["ハードロー", "ソフトロー", "判例法", "慣習法"], correct: 1, explanation: "ソフトローは強制力はないが、業界の自主規制として重要な役割を果たします。", keywords: ["ソフトロー", "ハードロー"] },
      { id: 4, question: "AIが特定のグループを不当に扱う問題を何と呼ぶか。", options: ["オーバーフィッティング", "アルゴリズムバイアス", "データリーケージ", "概念ドリフト"], correct: 1, explanation: "アルゴリズムバイアスは、学習データの偏りやアルゴリズムの設計に起因します。", keywords: ["アルゴリズムバイアス"] },
      { id: 5, question: "学習データが母集団を正しく反映していないことによるバイアスを何と呼ぶか。", options: ["アルゴリズムバイアス", "サンプリングバイアス", "確証バイアス", "生存バイアス"], correct: 1, explanation: "サンプリングバイアスはデータ収集の偏りによって生じます。", keywords: ["サンプリングバイアス"] },
      { id: 6, question: "AIの公平性を評価する際、直接使用しない方が良い属性を何と呼ぶか。", options: ["特徴量", "センシティブ属性", "目的変数", "説明変数"], correct: 1, explanation: "センシティブ属性（性別、人種など）は不当な差別につながる可能性があります。", keywords: ["センシティブ属性"] },
      { id: 7, question: "センシティブ属性と相関が高く、間接的に差別を生む変数を何と呼ぶか。", options: ["目的変数", "代理変数", "潜在変数", "交絡変数"], correct: 1, explanation: "代理変数は直接的にセンシティブ属性を使わなくても間接的に差別を生じさせます。", keywords: ["代理変数"] },
      { id: 8, question: "AIに小さな摂動を加えて誤った出力を引き出す攻撃を何と呼ぶか。", options: ["DoS攻撃", "Adversarial Attack", "フィッシング", "マルウェア"], correct: 1, explanation: "Adversarial Attackは人間には気づかない程度の入力変更でAIを騙します。", keywords: ["Adversarial Attack (Adversarial Examples)"] },
      { id: 9, question: "学習データを汚染してモデルの動作を変える攻撃を何と呼ぶか。", options: ["モデル窃取", "データ汚染", "Adversarial Attack", "バックドア攻撃"], correct: 1, explanation: "データ汚染は悪意のあるデータを混入させてモデルを操作します。", keywords: ["データ汚染"] },
      { id: 10, question: "設計段階からセキュリティを考慮する考え方を何と呼ぶか。", options: ["セキュリティ・バイ・デザイン", "ゼロトラスト", "多層防御", "最小権限"], correct: 0, explanation: "セキュリティ・バイ・デザインは設計段階からセキュリティを組み込みます。", keywords: ["セキュリティ・バイ・デザイン"] },
      { id: 11, question: "AIを使って作成された偽の動画や音声を何と呼ぶか。", options: ["フェイクニュース", "ディープフェイク", "ボット", "トロール"], correct: 1, explanation: "ディープフェイクは人物の顔や声を偽造し、悪用される恐れがあります。", keywords: ["ディープフェイク"] },
      { id: 12, question: "AIの判断根拠を人間が理解できる形で示すことを何と呼ぶか。", options: ["透明性", "説明可能性", "追跡可能性", "再現性"], correct: 1, explanation: "説明可能性は「なぜその判断をしたか」を説明できることです。", keywords: ["説明可能性"] },
      { id: 13, question: "AIシステムの内部が分からず、説明が困難な状態を何と呼ぶか。", options: ["ホワイトボックス", "グレーボックス", "ブラックボックス", "サンドボックス"], correct: 2, explanation: "ブラックボックスは入力と出力の関係は分かるが、内部の処理が不透明な状態です。", keywords: ["ブラックボックス"] },
      { id: 14, question: "学習データの出所や加工履歴を追跡できるようにすることを何と呼ぶか。", options: ["透明性", "説明可能性", "データの来歴", "監査可能性"], correct: 2, explanation: "データの来歴はデータがどこから来てどう処理されたかを記録します。", keywords: ["データの来歴"] },
      { id: 15, question: "自分の意見に合う情報ばかりが強化される現象を何と呼ぶか。", options: ["フィルターバブル", "エコーチェンバー", "確証バイアス", "バンドワゴン効果"], correct: 1, explanation: "エコーチェンバーは同じ意見の人々の間で情報が反響し合う現象です。", keywords: ["エコーチェンバー"] },
      { id: 16, question: "アルゴリズムによって自分の好みの情報しか見えなくなる現象を何と呼ぶか。", options: ["エコーチェンバー", "フィルターバブル", "情報の非対称性", "デジタルデバイド"], correct: 1, explanation: "フィルターバブルはパーソナライズにより多様な情報に触れにくくなる問題です。", keywords: ["フィルターバブル"] },
      { id: 17, question: "AI開発・運用における倫理的リスクを評価するプロセスを何と呼ぶか。", options: ["リスクアセスメント", "倫理アセスメント", "インパクト評価", "監査"], correct: 1, explanation: "倫理アセスメントはAIの社会的影響や倫理的リスクを事前に評価します。", keywords: ["倫理アセスメント"] },
      { id: 18, question: "AIシステムにおいて、重要な判断に人間が関与することを何と呼ぶか。", options: ["ヒューマン・オーバーサイト", "Human-in-the-Loop", "マニュアルモード", "監視機能"], correct: 1, explanation: "Human-in-the-LoopはAIが完全に自律せず、人間が介入・監視する仕組みです。", keywords: ["人間の関与"] },
      { id: 19, question: "AI開発チームの多様性を確保することを何と呼ぶか。", options: ["インクルージョン", "ダイバーシティ", "エクイティ", "アクセシビリティ"], correct: 1, explanation: "ダイバーシティは多様な視点を取り入れることで、バイアスの軽減に寄与します。", keywords: ["ダイバーシティ"] },
      { id: 20, question: "組織がAIを適切に開発・運用するための管理体制を何と呼ぶか。", options: ["AI倫理", "AIガバナンス", "AIポリシー", "AI監査"], correct: 1, explanation: "AIガバナンスはAIの開発・運用に関する方針、プロセス、責任体制を定めます。", keywords: ["AIガバナンス"] }
    ]
  }
};


// ============================================
// APIキー設定モーダル
// ============================================
function ApiKeyModal({ isOpen, onClose, apiKey, setApiKey }) {
  const [tempKey, setTempKey] = useState(apiKey);
  const [showKey, setShowKey] = useState(false);

  useEffect(() => {
    if (isOpen) {
      setTempKey(apiKey);
    }
  }, [isOpen, apiKey]);

  const handleSave = () => {
    setApiKey(tempKey);
    try {
      localStorage.setItem('anthropic-api-key', tempKey);
    } catch (e) {
      console.log('Failed to save API key');
    }
    onClose();
  };

  const handleClear = () => {
    setTempKey('');
    setApiKey('');
    try {
      localStorage.removeItem('anthropic-api-key');
    } catch (e) {
      console.log('Failed to remove API key');
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70 backdrop-blur-sm">
      <div className="bg-slate-800 rounded-3xl w-full max-w-md p-6 border border-slate-600 shadow-2xl">
        <div className="flex items-center justify-between mb-6">
          <h3 className="text-xl font-bold text-white">🔑 API設定</h3>
          <button 
            onClick={onClose}
            className="w-10 h-10 rounded-full bg-slate-700 hover:bg-slate-600 flex items-center justify-center transition-colors text-white"
          >
            ✕
          </button>
        </div>

        <div className="space-y-4">
          <div>
            <label className="block text-sm text-slate-400 mb-2">Anthropic APIキー</label>
            <div className="relative">
              <input
                type={showKey ? 'text' : 'password'}
                value={tempKey}
                onChange={(e) => setTempKey(e.target.value)}
                placeholder="sk-ant-api03-..."
                className="w-full bg-slate-700 border border-slate-600 rounded-xl px-4 py-3 text-sm focus:outline-none focus:border-purple-500 text-white placeholder-slate-500 pr-12"
              />
              <button
                onClick={() => setShowKey(!showKey)}
                className="absolute right-3 top-1/2 -translate-y-1/2 text-slate-400 hover:text-white"
              >
                {showKey ? '🙈' : '👁'}
              </button>
            </div>
          </div>

          <div className="bg-slate-700/50 rounded-xl p-4 text-sm">
            <p className="text-slate-300 mb-2">💡 APIキーの取得方法</p>
            <ol className="text-slate-400 space-y-1 list-decimal list-inside">
              <li><a href="https://console.anthropic.com/" target="_blank" rel="noopener noreferrer" className="text-purple-400 hover:underline">Anthropic Console</a> にアクセス</li>
              <li>アカウントを作成またはログイン</li>
              <li>API Keys からキーを発行</li>
            </ol>
          </div>

          <div className="bg-amber-500/10 border border-amber-500/30 rounded-xl p-4 text-sm">
            <p className="text-amber-400">⚠️ 注意</p>
            <p className="text-slate-400 mt-1">APIキーはブラウザに保存されます。共有PCでの使用にはご注意ください。AI質問機能を使用するとAPI使用料が発生します。</p>
          </div>

          <div className="flex gap-3 pt-2">
            <button
              onClick={handleClear}
              className="flex-1 py-3 rounded-xl font-bold bg-slate-700 hover:bg-slate-600 text-white transition-colors"
            >
              クリア
            </button>
            <button
              onClick={handleSave}
              className="flex-1 py-3 rounded-xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 text-white transition-colors"
            >
              保存
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

// ============================================
// AI質問モーダルコンポーネント
// ============================================
function AiChatModal({ isOpen, onClose, chapter, currentQuestion, apiKey, onOpenApiSettings }) {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef(null);

  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  useEffect(() => {
    if (isOpen) {
      setMessages([]);
      setInput('');
    }
  }, [isOpen, currentQuestion?.id]);

  const sendMessage = async () => {
    if (!input.trim() || isLoading) return;

    if (!apiKey) {
      setMessages(prev => [...prev, {
        role: 'assistant',
        content: 'APIキーが設定されていません。設定画面からAPIキーを入力してください。'
      }]);
      return;
    }

    const userMessage = input.trim();
    setInput('');
    setMessages(prev => [...prev, { role: 'user', content: userMessage }]);
    setIsLoading(true);

    try {
      const systemPrompt = `あなたは「${chapter.characterName}」です。G検定の学習をサポートしています。

キャラクター設定：
- 名言：「${chapter.quote}」
- 担当分野：${chapter.title}（${chapter.subtitle}）

現在、学習者は以下の問題に取り組んでいます：
【問題】${currentQuestion.question}
【選択肢】${currentQuestion.options.map((o, i) => `${['A','B','C','D'][i]}. ${o}`).join(' / ')}
【正解】${['A','B','C','D'][currentQuestion.correct]}. ${currentQuestion.options[currentQuestion.correct]}
【解説】${currentQuestion.explanation}
【関連キーワード】${currentQuestion.keywords.join(', ')}

以下のルールで回答してください：
1. キャラクターになりきって、親しみやすく教える
2. この問題に関連した内容を中心に説明する
3. G検定に出題される重要ポイントを押さえる
4. 具体例を交えて分かりやすく説明する
5. 回答は簡潔に（300文字程度を目安）
6. 直接答えを教えるのではなく、理解を助けるヒントを与える`;

      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01',
          'anthropic-dangerous-direct-browser-access': 'true'
        },
        body: JSON.stringify({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 1000,
          system: systemPrompt,
          messages: [
            ...messages.map(m => ({ role: m.role, content: m.content })),
            { role: 'user', content: userMessage }
          ]
        })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error?.message || `API Error: ${response.status}`);
      }

      const data = await response.json();
      const assistantMessage = data.content[0].text;
      setMessages(prev => [...prev, { role: 'assistant', content: assistantMessage }]);
    } catch (error) {
      let errorMessage = 'エラーが発生しました。';
      if (error.message.includes('401') || error.message.includes('invalid')) {
        errorMessage = 'APIキーが無効です。設定画面から正しいAPIキーを入力してください。';
      } else if (error.message.includes('429')) {
        errorMessage = 'API使用量の上限に達しました。しばらく待ってからお試しください。';
      } else if (error.message.includes('network') || error.message.includes('fetch')) {
        errorMessage = 'ネットワークエラーが発生しました。インターネット接続を確認してください。';
      }
      setMessages(prev => [...prev, {
        role: 'assistant',
        content: errorMessage
      }]);
    }
    setIsLoading(false);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70 backdrop-blur-sm">
      <div className="bg-slate-800 rounded-3xl w-full max-w-lg h-[80vh] max-h-[600px] flex flex-col border border-slate-600 shadow-2xl overflow-hidden">
        <div className="flex-shrink-0 p-4 border-b border-slate-700 flex items-center justify-between bg-slate-800/90">
          <div className="flex items-center gap-3">
            <span className="text-3xl">{chapter.character}</span>
            <div>
              <div className="font-bold" style={{ color: chapter.color }}>{chapter.characterName}</div>
              <div className="text-xs text-slate-400">に質問する</div>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <button 
              onClick={onOpenApiSettings}
              className="w-10 h-10 rounded-full bg-slate-700 hover:bg-slate-600 flex items-center justify-center transition-colors text-white text-sm"
              title="API設定"
            >
              ⚙️
            </button>
            <button onClick={onClose} className="w-10 h-10 rounded-full bg-slate-700 hover:bg-slate-600 flex items-center justify-center transition-colors text-white">✕</button>
          </div>
        </div>

        <div className="flex-1 overflow-y-auto p-4 space-y-4 min-h-0">
          {!apiKey && (
            <div className="bg-amber-500/10 border border-amber-500/30 rounded-xl p-4 text-center">
              <p className="text-amber-400 mb-2">⚠️ APIキーが未設定です</p>
              <button
                onClick={onOpenApiSettings}
                className="px-4 py-2 bg-amber-500 hover:bg-amber-400 text-black rounded-lg font-bold text-sm transition-colors"
              >
                APIキーを設定する
              </button>
            </div>
          )}

          {messages.length === 0 && apiKey && (
            <div className="text-center text-slate-500 py-4">
              <p className="mb-4 text-sm">この問題について質問できます</p>
              <div className="space-y-2">
                {['この問題のポイントを教えて', 'なぜこれが正解なの？', '関連する概念を説明して', '覚え方のコツはある？'].map((suggestion, idx) => (
                  <button key={idx} onClick={() => setInput(suggestion)} className="block w-full text-left p-3 bg-slate-700/50 hover:bg-slate-600/50 rounded-xl text-sm text-slate-300 border border-slate-600 transition-colors">
                    💬 {suggestion}
                  </button>
                ))}
              </div>
            </div>
          )}

          {messages.map((msg, idx) => (
            <div key={idx} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
              <div className={`max-w-[85%] p-3 rounded-2xl ${msg.role === 'user' ? 'bg-purple-600 rounded-br-sm' : 'bg-slate-700 rounded-bl-sm'}`}>
                {msg.role === 'assistant' && (
                  <div className="flex items-center gap-2 mb-2 text-xs font-bold" style={{ color: chapter.color }}>
                    <span>{chapter.character}</span>
                    {chapter.characterName}
                  </div>
                )}
                <p className="text-sm whitespace-pre-wrap text-white">{msg.content}</p>
              </div>
            </div>
          ))}

          {isLoading && (
            <div className="flex justify-start">
              <div className="bg-slate-700 p-3 rounded-2xl rounded-bl-sm">
                <div className="flex items-center gap-1">
                  <span className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                  <span className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                  <span className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                </div>
              </div>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>

        <div className="flex-shrink-0 p-4 border-t border-slate-700 bg-slate-800/90">
          <div className="flex gap-2">
            <input
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
              placeholder={apiKey ? "質問を入力..." : "APIキーを設定してください"}
              disabled={!apiKey}
              className="flex-1 bg-slate-700 border border-slate-600 rounded-xl px-4 py-3 text-sm focus:outline-none focus:border-purple-500 text-white placeholder-slate-400 disabled:opacity-50"
            />
            <button
              onClick={sendMessage}
              disabled={!input.trim() || isLoading || !apiKey}
              className={`px-5 py-3 rounded-xl font-bold text-sm transition-all text-white ${input.trim() && !isLoading && apiKey ? 'bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500' : 'bg-slate-700 text-slate-500 cursor-not-allowed'}`}
            >
              送信
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

// ============================================
// メインアプリケーション
// ============================================
function GKenteiQuizApp() {
  const [mode, setMode] = useState('home');
  const [currentChapter, setCurrentChapter] = useState(null);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [showExplanation, setShowExplanation] = useState(false);
  const [answers, setAnswers] = useState([]);
  const [chapterScores, setChapterScores] = useState({});
  const [wrongQuestions, setWrongQuestions] = useState([]);
  const [isReviewMode, setIsReviewMode] = useState(false);
  const [isAiModalOpen, setIsAiModalOpen] = useState(false);
  const [isApiModalOpen, setIsApiModalOpen] = useState(false);
  const [randomQuestions, setRandomQuestions] = useState([]);
  const [apiKey, setApiKey] = useState('');

  // localStorageからの読み込み
  useEffect(() => {
    try {
      const savedScores = localStorage.getItem('gkentei-scores-v3');
      if (savedScores) setChapterScores(JSON.parse(savedScores));
      const savedWrong = localStorage.getItem('gkentei-wrong-v3');
      if (savedWrong) setWrongQuestions(JSON.parse(savedWrong));
      const savedApiKey = localStorage.getItem('anthropic-api-key');
      if (savedApiKey) setApiKey(savedApiKey);
    } catch (e) {
      console.log('Storage not available');
    }
  }, []);

  // 進捗の保存
  const saveProgress = (scores, wrong) => {
    try {
      localStorage.setItem('gkentei-scores-v3', JSON.stringify(scores));
      localStorage.setItem('gkentei-wrong-v3', JSON.stringify(wrong));
    } catch (e) {
      console.log('Failed to save progress');
    }
  };

  // 章の開始
  const startChapter = (chapterId) => {
    const chapter = Object.values(quizData).find(c => c.id === chapterId);
    setCurrentChapter(chapter);
    setCurrentQuestionIndex(0);
    setSelectedAnswer(null);
    setShowExplanation(false);
    setAnswers([]);
    setIsReviewMode(false);
    setMode('quiz');
  };

  // ランダム出題
  const startRandomQuiz = () => {
    const allQuestions = [];
    Object.values(quizData).forEach(chapter => {
      chapter.questions.forEach(q => {
        allQuestions.push({ ...q, chapterId: chapter.id, chapterTitle: chapter.title });
      });
    });
    const shuffled = allQuestions.sort(() => Math.random() - 0.5).slice(0, 20);
    setRandomQuestions(shuffled);
    setCurrentChapter({ 
      id: 'random',
      title: 'ランダム出題', 
      subtitle: '全章から20問', 
      character: '🎲', 
      characterName: 'ランダムマスター',
      quote: '運と実力を試せ！',
      color: '#6366F1' 
    });
    setCurrentQuestionIndex(0);
    setSelectedAnswer(null);
    setShowExplanation(false);
    setAnswers([]);
    setIsReviewMode(false);
    setMode('random');
  };

  // 復習モードの開始
  const startReview = () => {
    if (wrongQuestions.length === 0) return;
    setIsReviewMode(true);
    setCurrentQuestionIndex(0);
    setSelectedAnswer(null);
    setShowExplanation(false);
    setAnswers([]);
    setMode('review');
  };

  // 弱点分析データの取得
  const getWeakAnalysis = () => {
    const chapterWrongCount = {};
    wrongQuestions.forEach(wq => {
      chapterWrongCount[wq.chapterId] = (chapterWrongCount[wq.chapterId] || 0) + 1;
    });
    
    return Object.entries(chapterWrongCount)
      .map(([chapterId, count]) => ({
        chapter: quizData[`chapter${chapterId}`],
        count
      }))
      .sort((a, b) => b.count - a.count);
  };

  // 回答選択
  const selectAnswer = (index) => {
    if (showExplanation) return;
    setSelectedAnswer(index);
  };

  // 回答確定
  const confirmAnswer = () => {
    if (selectedAnswer === null) return;
    setShowExplanation(true);
    
    let currentQuestion;
    if (mode === 'random') {
      currentQuestion = randomQuestions[currentQuestionIndex];
    } else if (isReviewMode && mode === 'review') {
      currentQuestion = wrongQuestions[currentQuestionIndex];
    } else {
      currentQuestion = currentChapter.questions[currentQuestionIndex];
    }
    
    const isCorrect = selectedAnswer === currentQuestion.correct;
    setAnswers([...answers, { questionId: currentQuestion.id, selected: selectedAnswer, correct: isCorrect }]);
    
    // 間違えた問題を記録（復習モード以外）
    if (!isCorrect && mode !== 'review') {
      const chapterId = currentQuestion.chapterId || currentChapter?.id;
      const newWrong = [...wrongQuestions];
      const exists = newWrong.find(w => w.chapterId === chapterId && w.questionId === currentQuestion.id);
      if (!exists && chapterId !== 'random') {
        newWrong.push({ 
          ...currentQuestion, 
          chapterId, 
          chapterTitle: currentQuestion.chapterTitle || currentChapter?.title 
        });
        setWrongQuestions(newWrong);
        saveProgress(chapterScores, newWrong);
      }
    }
  };

  // 次の問題へ
  const nextQuestion = () => {
    let questions;
    if (mode === 'random') {
      questions = randomQuestions;
    } else if (isReviewMode && mode === 'review') {
      questions = wrongQuestions;
    } else {
      questions = currentChapter.questions;
    }
    
    if (currentQuestionIndex < questions.length - 1) {
      setCurrentQuestionIndex(currentQuestionIndex + 1);
      setSelectedAnswer(null);
      setShowExplanation(false);
    } else {
      finishQuiz();
    }
  };

  // クイズ終了
  const finishQuiz = () => {
    if (mode === 'review') {
      const stillWrong = wrongQuestions.filter((q, idx) => {
        const answer = answers[idx];
        return answer && !answer.correct;
      });
      setWrongQuestions(stillWrong);
      saveProgress(chapterScores, stillWrong);
    } else if (mode === 'quiz') {
      const correctCount = answers.filter(a => a.correct).length;
      const score = Math.round((correctCount / currentChapter.questions.length) * 100);
      const newScores = { ...chapterScores, [currentChapter.id]: score };
      setChapterScores(newScores);
      const newWrong = currentChapter.questions.filter((q, idx) => {
        const answer = answers[idx];
        return answer && !answer.correct;
      }).map(q => ({ ...q, chapterId: currentChapter.id, chapterTitle: currentChapter.title }));
      const updatedWrong = [...wrongQuestions.filter(w => w.chapterId !== currentChapter.id), ...newWrong];
      setWrongQuestions(updatedWrong);
      saveProgress(newScores, updatedWrong);
    }
    setMode('results');
  };

  // 全体の進捗計算
  const calculateOverallProgress = () => {
    const totalChapters = Object.keys(quizData).length;
    const completedChapters = Object.keys(chapterScores).length;
    const averageScore = completedChapters > 0
      ? Math.round(Object.values(chapterScores).reduce((a, b) => a + b, 0) / completedChapters)
      : 0;
    return { completedChapters, totalChapters, averageScore };
  };

  // ============================================
  // ホーム画面
  // ============================================
  const renderHome = () => {
    const progress = calculateOverallProgress();
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white p-4 md:p-8">
        <header className="text-center mb-8">
          <h1 className="text-3xl md:text-5xl font-black mb-2 bg-gradient-to-r from-yellow-400 via-pink-500 to-purple-500 bg-clip-text text-transparent">
            G検定クイズマスター
          </h1>
          <p className="text-slate-400 text-sm md:text-base">全180問でディープラーニングをマスターしよう！</p>
        </header>

        {/* API設定ボタン */}
        <div className="max-w-2xl mx-auto mb-4 flex justify-end">
          <button
            onClick={() => setIsApiModalOpen(true)}
            className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-bold transition-all ${
              apiKey 
                ? 'bg-green-500/20 text-green-400 border border-green-500/30 hover:bg-green-500/30' 
                : 'bg-amber-500/20 text-amber-400 border border-amber-500/30 hover:bg-amber-500/30'
            }`}
          >
            {apiKey ? '✓ API設定済み' : '⚙️ API設定'}
          </button>
        </div>

        {/* 進捗バー */}
        <div className="max-w-2xl mx-auto mb-8 bg-slate-800/50 rounded-2xl p-4 border border-slate-700">
          <div className="flex justify-between items-center mb-2">
            <span className="text-sm text-slate-400">学習進捗</span>
            <span className="text-sm font-bold text-yellow-400">{progress.completedChapters}/{progress.totalChapters}章 完了</span>
          </div>
          <div className="h-3 bg-slate-700 rounded-full overflow-hidden">
            <div className="h-full bg-gradient-to-r from-green-400 to-emerald-500 transition-all duration-500"
              style={{ width: `${(progress.completedChapters / progress.totalChapters) * 100}%` }} />
          </div>
          {progress.averageScore > 0 && (
            <p className="text-center mt-2 text-sm text-slate-400">
              平均スコア: <span className="text-white font-bold">{progress.averageScore}%</span>
            </p>
          )}
        </div>

        {/* メニューボタン */}
        <div className="max-w-2xl mx-auto grid grid-cols-2 gap-4 mb-8">
          <button onClick={() => setMode('chapter')}
            className="bg-gradient-to-br from-indigo-600 to-purple-700 hover:from-indigo-500 hover:to-purple-600 p-6 rounded-2xl text-left transition-all hover:scale-105">
            <div className="text-3xl mb-2">📚</div>
            <div className="font-bold text-lg">章別学習</div>
            <div className="text-sm text-slate-300">9章 × 20問</div>
          </button>
          <button onClick={startRandomQuiz}
            className="bg-gradient-to-br from-violet-600 to-indigo-700 hover:from-violet-500 hover:to-indigo-600 p-6 rounded-2xl text-left transition-all hover:scale-105">
            <div className="text-3xl mb-2">🎲</div>
            <div className="font-bold text-lg">ランダム</div>
            <div className="text-sm text-slate-300">全章から20問</div>
          </button>
          <button onClick={startReview} disabled={wrongQuestions.length === 0}
            className={`p-6 rounded-2xl text-left transition-all ${wrongQuestions.length > 0 ? 'bg-gradient-to-br from-rose-600 to-pink-700 hover:from-rose-500 hover:to-pink-600 hover:scale-105' : 'bg-slate-700 opacity-50 cursor-not-allowed'}`}>
            <div className="text-3xl mb-2">🔄</div>
            <div className="font-bold text-lg">復習モード</div>
            <div className="text-sm text-slate-300">{wrongQuestions.length > 0 ? `${wrongQuestions.length}問` : '間違いなし'}</div>
          </button>
          <button onClick={() => setMode('analysis')}
            className="bg-gradient-to-br from-emerald-600 to-teal-700 hover:from-emerald-500 hover:to-teal-600 p-6 rounded-2xl text-left transition-all hover:scale-105">
            <div className="text-3xl mb-2">📊</div>
            <div className="font-bold text-lg">弱点分析</div>
            <div className="text-sm text-slate-300">苦手分野を確認</div>
          </button>
        </div>

        {/* 弱点診断 */}
        {Object.keys(chapterScores).length > 0 && (
          <div className="max-w-2xl mx-auto bg-slate-800/50 rounded-2xl p-4 border border-slate-700">
            <h3 className="font-bold mb-4 flex items-center gap-2"><span>📊</span> 章別スコア</h3>
            <div className="space-y-2">
              {Object.values(quizData).map(chapter => {
                const score = chapterScores[chapter.id];
                return (
                  <div key={chapter.id} className="flex items-center gap-3">
                    <span className="text-sm w-32 truncate">{chapter.title}</span>
                    <div className="flex-1 h-2 bg-slate-700 rounded-full overflow-hidden">
                      <div className={`h-full transition-all duration-500 ${score >= 80 ? 'bg-green-500' : score >= 60 ? 'bg-yellow-500' : score ? 'bg-red-500' : 'bg-slate-600'}`}
                        style={{ width: `${score || 0}%` }} />
                    </div>
                    <span className={`text-sm w-12 text-right font-bold ${score >= 80 ? 'text-green-400' : score >= 60 ? 'text-yellow-400' : score ? 'text-red-400' : 'text-slate-500'}`}>
                      {score !== undefined ? `${score}%` : '—'}
                    </span>
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* APIキー設定モーダル */}
        <ApiKeyModal
          isOpen={isApiModalOpen}
          onClose={() => setIsApiModalOpen(false)}
          apiKey={apiKey}
          setApiKey={setApiKey}
        />
      </div>
    );
  };

  // ============================================
  // 章選択画面
  // ============================================
  const renderChapterSelect = () => (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white p-4 md:p-8">
      <button onClick={() => setMode('home')} className="mb-6 flex items-center gap-2 text-slate-400 hover:text-white transition-colors">
        <span>←</span> ホームに戻る
      </button>
      <h2 className="text-2xl font-bold mb-6 text-center">章を選択</h2>
      <div className="max-w-4xl mx-auto grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {Object.values(quizData).map(chapter => {
          const score = chapterScores[chapter.id];
          return (
            <button key={chapter.id} onClick={() => startChapter(chapter.id)}
              className="bg-slate-800/80 hover:bg-slate-700/80 border border-slate-700 hover:border-slate-500 rounded-2xl p-5 text-left transition-all hover:scale-102"
              style={{ borderLeftColor: chapter.color, borderLeftWidth: '4px' }}>
              <div className="flex items-start justify-between mb-3">
                <span className="text-3xl">{chapter.character}</span>
                {score !== undefined && (
                  <span className={`text-sm font-bold px-2 py-1 rounded-full ${score >= 80 ? 'bg-green-500/20 text-green-400' : score >= 60 ? 'bg-yellow-500/20 text-yellow-400' : 'bg-red-500/20 text-red-400'}`}>
                    {score}%
                  </span>
                )}
              </div>
              <div className="font-bold text-lg mb-1">第{chapter.id}章: {chapter.title}</div>
              <div className="text-sm text-slate-400 mb-2">{chapter.subtitle}</div>
              <div className="text-xs text-slate-500 italic">「{chapter.quote}」</div>
              <div className="text-xs text-slate-500 mt-2">20問</div>
            </button>
          );
        })}
      </div>
    </div>
  );

  // ============================================
  // 弱点分析画面
  // ============================================
  const renderAnalysis = () => {
    const weakAnalysis = getWeakAnalysis();

    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white p-4 md:p-8">
        <div className="max-w-2xl mx-auto">
          <button 
            onClick={() => setMode('home')}
            className="text-slate-400 hover:text-white mb-6 flex items-center gap-2"
          >
            ← ホームに戻る
          </button>
          
          <h2 className="text-2xl font-bold text-white mb-6 text-center">📊 弱点分析</h2>
          
          {weakAnalysis.length === 0 ? (
            <div className="bg-slate-800/80 rounded-2xl p-8 text-center border border-slate-700">
              <div className="text-5xl mb-4">🎯</div>
              <p className="text-slate-300 text-lg mb-2">まだ間違えた問題がありません</p>
              <p className="text-slate-500 text-sm">問題を解いて弱点を発見しましょう！</p>
            </div>
          ) : (
            <div className="space-y-4">
              <div className="bg-slate-800/50 rounded-2xl p-4 border border-slate-700 mb-6">
                <p className="text-center text-slate-400">
                  間違えた問題: <span className="text-white font-bold text-xl">{wrongQuestions.length}問</span>
                </p>
              </div>
              
              {weakAnalysis.map(({ chapter, count }) => (
                <div key={chapter.id} className="bg-slate-800/80 rounded-xl p-4 border border-slate-700">
                  <div className="flex items-center gap-4">
                    <div 
                      className="w-14 h-14 rounded-xl flex items-center justify-center text-2xl"
                      style={{ backgroundColor: chapter.color + '30' }}
                    >
                      {chapter.character}
                    </div>
                    <div className="flex-1">
                      <div className="text-white font-bold">{chapter.title}</div>
                      <div className="text-slate-500 text-sm">{chapter.subtitle}</div>
                    </div>
                    <div className="text-right">
                      <div className="text-3xl font-bold text-red-400">{count}</div>
                      <div className="text-slate-500 text-xs">要復習</div>
                    </div>
                  </div>
                  <div className="mt-3">
                    <div className="h-2 bg-slate-700 rounded-full overflow-hidden">
                      <div 
                        className="h-full bg-red-500 transition-all duration-500"
                        style={{ width: `${Math.min((count / 20) * 100, 100)}%` }}
                      />
                    </div>
                  </div>
                </div>
              ))}
              
              <button
                onClick={startReview}
                className="w-full py-4 bg-gradient-to-r from-rose-600 to-pink-600 hover:from-rose-500 hover:to-pink-500 text-white rounded-2xl font-bold mt-6 transition-all hover:scale-105"
              >
                🔄 復習モードを開始
              </button>
            </div>
          )}
        </div>
      </div>
    );
  };

  // ============================================
  // クイズ画面
  // ============================================
  const renderQuiz = () => {
    // モードに応じて問題セットを選択
    let questions;
    if (mode === 'random') {
      questions = randomQuestions;
    } else if (isReviewMode && mode === 'review') {
      questions = wrongQuestions;
    } else {
      questions = currentChapter?.questions;
    }
    
    if (!questions || questions.length === 0) return null;

    const currentQuestion = questions[currentQuestionIndex];
    const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
    
    // チャプター情報の取得（ランダム/復習モードでは問題ごとに異なる可能性あり）
    let chapter;
    if (mode === 'random' || mode === 'review') {
      chapter = currentQuestion.chapterId 
        ? Object.values(quizData).find(c => c.id === currentQuestion.chapterId)
        : currentChapter;
    } else {
      chapter = currentChapter;
    }

    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white p-4 md:p-8">
        {/* AI質問モーダル */}
        <AiChatModal
          isOpen={isAiModalOpen}
          onClose={() => setIsAiModalOpen(false)}
          chapter={chapter || currentChapter}
          currentQuestion={currentQuestion}
          apiKey={apiKey}
          onOpenApiSettings={() => {
            setIsAiModalOpen(false);
            setIsApiModalOpen(true);
          }}
        />

        {/* APIキー設定モーダル */}
        <ApiKeyModal
          isOpen={isApiModalOpen}
          onClose={() => setIsApiModalOpen(false)}
          apiKey={apiKey}
          setApiKey={setApiKey}
        />

        {/* ヘッダー */}
        <div className="max-w-3xl mx-auto mb-6">
          <div className="flex items-center justify-between mb-4">
            <button onClick={() => setMode('home')} className="text-slate-400 hover:text-white transition-colors">✕ 終了</button>
            <span className="text-sm text-slate-400">
              {mode === 'review' ? '復習モード' : mode === 'random' ? 'ランダム出題' : `第${chapter?.id}章: ${chapter?.title}`}
            </span>
            <span className="font-bold">{currentQuestionIndex + 1} / {questions.length}</span>
          </div>
          <div className="h-2 bg-slate-700 rounded-full overflow-hidden">
            <div className="h-full bg-gradient-to-r from-purple-500 to-pink-500 transition-all duration-300" style={{ width: `${progress}%` }} />
          </div>
        </div>

        {/* 問題カード */}
        <div className="max-w-3xl mx-auto">
          <div className="bg-slate-800/80 rounded-3xl p-6 md:p-8 border border-slate-700 mb-6">
            {/* キャラクターとAI質問ボタン */}
            <div className="flex items-center justify-between mb-6 pb-4 border-b border-slate-700">
              <div className="flex items-center gap-3">
                <span className="text-4xl">{chapter?.character || currentChapter?.character}</span>
                <div>
                  <div className="font-bold" style={{ color: chapter?.color || currentChapter?.color }}>{chapter?.characterName || currentChapter?.characterName}</div>
                  <div className="text-xs text-slate-400">{chapter?.subtitle || currentChapter?.subtitle}</div>
                </div>
              </div>
              <button
                onClick={() => setIsAiModalOpen(true)}
                className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-bold transition-all hover:scale-105 ${
                  apiKey 
                    ? 'bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-400 hover:to-orange-400' 
                    : 'bg-slate-600 hover:bg-slate-500'
                }`}
              >
                🤖 質問する
              </button>
            </div>

            {/* 問題文 */}
            <div className="text-lg md:text-xl font-medium mb-8 leading-relaxed">
              Q{currentQuestionIndex + 1}. {currentQuestion.question}
            </div>

            {/* 選択肢 */}
            <div className="space-y-3">
              {currentQuestion.options.map((option, idx) => {
                let buttonClass = 'bg-slate-700/50 hover:bg-slate-600/50 border-slate-600';
                if (showExplanation) {
                  if (idx === currentQuestion.correct) {
                    buttonClass = 'bg-green-500/20 border-green-500 text-green-300';
                  } else if (idx === selectedAnswer && idx !== currentQuestion.correct) {
                    buttonClass = 'bg-red-500/20 border-red-500 text-red-300';
                  }
                } else if (idx === selectedAnswer) {
                  buttonClass = 'bg-purple-500/30 border-purple-500';
                }
                return (
                  <button key={idx} onClick={() => selectAnswer(idx)} disabled={showExplanation}
                    className={`w-full p-4 rounded-xl text-left border-2 transition-all ${buttonClass}`}>
                    <span className="font-bold mr-3 text-slate-400">{['A', 'B', 'C', 'D'][idx]}.</span>
                    {option}
                  </button>
                );
              })}
            </div>
          </div>

          {/* 解説 */}
          {showExplanation && (
            <div className="bg-slate-800/80 rounded-3xl p-6 border border-slate-700 mb-6">
              <div className={`font-bold text-lg mb-3 ${selectedAnswer === currentQuestion.correct ? 'text-green-400' : 'text-red-400'}`}>
                {selectedAnswer === currentQuestion.correct ? '✓ 正解！' : '✗ 不正解'}
              </div>
              <p className="text-slate-300 leading-relaxed mb-4">{currentQuestion.explanation}</p>
              <div className="flex flex-wrap gap-2">
                {currentQuestion.keywords.map((kw, idx) => (
                  <span key={idx} className="text-xs bg-purple-500/20 text-purple-300 px-2 py-1 rounded-full">#{kw}</span>
                ))}
              </div>
            </div>
          )}

          {/* ボタン */}
          <div className="flex justify-center gap-4">
            {!showExplanation ? (
              <button onClick={confirmAnswer} disabled={selectedAnswer === null}
                className={`px-8 py-4 rounded-2xl font-bold text-lg transition-all ${selectedAnswer !== null ? 'bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 hover:scale-105' : 'bg-slate-700 text-slate-500 cursor-not-allowed'}`}>
                回答する
              </button>
            ) : (
              <button onClick={nextQuestion}
                className="px-8 py-4 rounded-2xl font-bold text-lg bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 hover:scale-105 transition-all">
                {currentQuestionIndex < questions.length - 1 ? '次の問題 →' : '結果を見る'}
              </button>
            )}
          </div>
        </div>
      </div>
    );
  };

  // ============================================
  // 結果画面
  // ============================================
  const renderResults = () => {
    const correctCount = answers.filter(a => a.correct).length;
    const totalCount = answers.length;
    const score = Math.round((correctCount / totalCount) * 100);
    let message = '', emoji = '';
    if (score >= 90) { message = '素晴らしい！完璧に近い成績です！'; emoji = '🏆'; }
    else if (score >= 80) { message = '合格ラインクリア！この調子で！'; emoji = '🎉'; }
    else if (score >= 70) { message = 'もう少し！復習で弱点克服を！'; emoji = '💪'; }
    else { message = '基礎固めが必要です。復習しましょう！'; emoji = '📚'; }

    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white p-4 md:p-8 flex items-center justify-center">
        <div className="max-w-lg w-full">
          <div className="bg-slate-800/80 rounded-3xl p-8 border border-slate-700 text-center">
            <div className="text-6xl mb-4">{emoji}</div>
            <h2 className="text-2xl font-bold mb-2">
              {mode === 'review' ? '復習完了！' : mode === 'random' ? 'ランダム出題完了！' : `第${currentChapter?.id}章 完了！`}
            </h2>
            <div className="my-8">
              <div className={`text-7xl font-black ${score >= 80 ? 'text-green-400' : score >= 60 ? 'text-yellow-400' : 'text-red-400'}`}>{score}%</div>
              <div className="text-slate-400 mt-2">{correctCount} / {totalCount} 問正解</div>
            </div>
            <p className="text-slate-300 mb-8">{message}</p>
            <div className="space-y-3">
              <button onClick={() => setMode('home')} className="w-full py-4 rounded-xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 transition-all">
                ホームに戻る
              </button>
              {mode === 'quiz' && (
                <button onClick={() => startChapter(currentChapter.id)} className="w-full py-4 rounded-xl font-bold bg-slate-700 hover:bg-slate-600 transition-all">
                  もう一度挑戦
                </button>
              )}
              {wrongQuestions.length > 0 && mode !== 'review' && (
                <button onClick={() => setMode('analysis')} className="w-full py-4 rounded-xl font-bold bg-slate-700 hover:bg-slate-600 transition-all">
                  📊 弱点分析を見る
                </button>
              )}
            </div>
          </div>
        </div>
      </div>
    );
  };

  // 画面切り替え
  switch (mode) {
    case 'home': return renderHome();
    case 'chapter': return renderChapterSelect();
    case 'analysis': return renderAnalysis();
    case 'quiz':
    case 'random':
    case 'review': return renderQuiz();
    case 'results': return renderResults();
    default: return renderHome();
  }
}
export default class QuizOnlyView {
  render() {
    const container = document.createElement('div');
    container.style.width = '100%';
    container.style.height = '100%';

    const root = createRoot(container);
    root.render(<GKenteiQuizApp />);

    return container;
  }
}
